{"code":"import { HttpRequest as __HttpRequest } from \"@aws-sdk/protocol-http\";\r\nimport { dateToUtcString as __dateToUtcString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, } from \"@aws-sdk/smithy-client\";\r\nimport { XmlNode as __XmlNode, XmlText as __XmlText } from \"@aws-sdk/xml-builder\";\r\nimport { parse as xmlParse } from \"fast-xml-parser\";\r\nexport const serializeAws_restXmlAbortMultipartUploadCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"AbortMultipartUpload\",\r\n        ...(input.UploadId !== undefined && { uploadId: input.UploadId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlCompleteMultipartUploadCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        ...(input.UploadId !== undefined && { uploadId: input.UploadId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.MultipartUpload !== undefined) {\r\n        contents = serializeAws_restXmlCompletedMultipartUpload(input.MultipartUpload, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"POST\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlCopyObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockLegalHoldStatus) && {\r\n            \"x-amz-object-lock-legal-hold\": input.ObjectLockLegalHoldStatus,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSKeyId) && {\r\n            \"x-amz-server-side-encryption-aws-kms-key-id\": input.SSEKMSKeyId,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerAlgorithm) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-algorithm\": input.CopySourceSSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentEncoding) && { \"Content-Encoding\": input.ContentEncoding }),\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfUnmodifiedSince) && {\r\n            \"x-amz-copy-source-if-unmodified-since\": __dateToUtcString(input.CopySourceIfUnmodifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.TaggingDirective) && { \"x-amz-tagging-directive\": input.TaggingDirective }),\r\n        ...(isSerializableHeaderValue(input.ContentLanguage) && { \"Content-Language\": input.ContentLanguage }),\r\n        ...(isSerializableHeaderValue(input.ContentDisposition) && { \"Content-Disposition\": input.ContentDisposition }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfMatch) && {\r\n            \"x-amz-copy-source-if-match\": input.CopySourceIfMatch,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentType) && { \"Content-Type\": input.ContentType }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerKeyMD5) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-key-MD5\": input.CopySourceSSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockRetainUntilDate) && {\r\n            \"x-amz-object-lock-retain-until-date\": (input.ObjectLockRetainUntilDate.toISOString().split(\".\")[0] + \"Z\").toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.Expires) && { Expires: __dateToUtcString(input.Expires).toString() }),\r\n        ...(isSerializableHeaderValue(input.Tagging) && { \"x-amz-tagging\": input.Tagging }),\r\n        ...(isSerializableHeaderValue(input.WebsiteRedirectLocation) && {\r\n            \"x-amz-website-redirect-location\": input.WebsiteRedirectLocation,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n        ...(isSerializableHeaderValue(input.CacheControl) && { \"Cache-Control\": input.CacheControl }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySource) && { \"x-amz-copy-source\": input.CopySource }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerKey) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-key\": input.CopySourceSSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.StorageClass) && { \"x-amz-storage-class\": input.StorageClass }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfModifiedSince) && {\r\n            \"x-amz-copy-source-if-modified-since\": __dateToUtcString(input.CopySourceIfModifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfNoneMatch) && {\r\n            \"x-amz-copy-source-if-none-match\": input.CopySourceIfNoneMatch,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSEncryptionContext) && {\r\n            \"x-amz-server-side-encryption-context\": input.SSEKMSEncryptionContext,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ServerSideEncryption) && {\r\n            \"x-amz-server-side-encryption\": input.ServerSideEncryption,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.MetadataDirective) && { \"x-amz-metadata-directive\": input.MetadataDirective }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockMode) && { \"x-amz-object-lock-mode\": input.ObjectLockMode }),\r\n        ...(input.Metadata !== undefined &&\r\n            Object.keys(input.Metadata).reduce((acc, suffix) => {\r\n                acc[\"x-amz-meta-\" + suffix] = input.Metadata[suffix];\r\n                return acc;\r\n            }, {})),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"CopyObject\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlCreateBucketCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.GrantWrite) && { \"x-amz-grant-write\": input.GrantWrite }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockEnabledForBucket) && {\r\n            \"x-amz-bucket-object-lock-enabled\": input.ObjectLockEnabledForBucket.toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    let body;\r\n    let contents;\r\n    if (input.CreateBucketConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlCreateBucketConfiguration(input.CreateBucketConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlCreateMultipartUploadCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.ServerSideEncryption) && {\r\n            \"x-amz-server-side-encryption\": input.ServerSideEncryption,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.WebsiteRedirectLocation) && {\r\n            \"x-amz-website-redirect-location\": input.WebsiteRedirectLocation,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n        ...(isSerializableHeaderValue(input.Tagging) && { \"x-amz-tagging\": input.Tagging }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n        ...(isSerializableHeaderValue(input.Expires) && { Expires: __dateToUtcString(input.Expires).toString() }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockLegalHoldStatus) && {\r\n            \"x-amz-object-lock-legal-hold\": input.ObjectLockLegalHoldStatus,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CacheControl) && { \"Cache-Control\": input.CacheControl }),\r\n        ...(isSerializableHeaderValue(input.ContentType) && { \"Content-Type\": input.ContentType }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockMode) && { \"x-amz-object-lock-mode\": input.ObjectLockMode }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSKeyId) && {\r\n            \"x-amz-server-side-encryption-aws-kms-key-id\": input.SSEKMSKeyId,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentLanguage) && { \"Content-Language\": input.ContentLanguage }),\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockRetainUntilDate) && {\r\n            \"x-amz-object-lock-retain-until-date\": (input.ObjectLockRetainUntilDate.toISOString().split(\".\")[0] + \"Z\").toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentDisposition) && { \"Content-Disposition\": input.ContentDisposition }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentEncoding) && { \"Content-Encoding\": input.ContentEncoding }),\r\n        ...(isSerializableHeaderValue(input.StorageClass) && { \"x-amz-storage-class\": input.StorageClass }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSEncryptionContext) && {\r\n            \"x-amz-server-side-encryption-context\": input.SSEKMSEncryptionContext,\r\n        }),\r\n        ...(input.Metadata !== undefined &&\r\n            Object.keys(input.Metadata).reduce((acc, suffix) => {\r\n                acc[\"x-amz-meta-\" + suffix] = input.Metadata[suffix];\r\n                return acc;\r\n            }, {})),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        uploads: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"POST\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketAnalyticsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        analytics: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketCorsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        cors: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketEncryptionCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        encryption: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketInventoryConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        inventory: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketLifecycleCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        lifecycle: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketMetricsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        metrics: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketPolicyCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        policy: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketReplicationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        replication: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteBucketWebsiteCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        website: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.MFA) && { \"x-amz-mfa\": input.MFA }),\r\n        ...(isSerializableHeaderValue(input.BypassGovernanceRetention) && {\r\n            \"x-amz-bypass-governance-retention\": input.BypassGovernanceRetention.toString(),\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"DeleteObject\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteObjectsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.BypassGovernanceRetention) && {\r\n            \"x-amz-bypass-governance-retention\": input.BypassGovernanceRetention.toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.MFA) && { \"x-amz-mfa\": input.MFA }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        delete: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Delete !== undefined) {\r\n        contents = serializeAws_restXmlDelete(input.Delete, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"POST\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeleteObjectTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlDeletePublicAccessBlockCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        publicAccessBlock: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"DELETE\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketAccelerateConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        accelerate: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketAclCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        acl: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketAnalyticsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        analytics: \"\",\r\n        \"x-id\": \"GetBucketAnalyticsConfiguration\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketCorsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        cors: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketEncryptionCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        encryption: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketInventoryConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        inventory: \"\",\r\n        \"x-id\": \"GetBucketInventoryConfiguration\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketLifecycleConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        lifecycle: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketLocationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        location: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketLoggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        logging: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketMetricsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        metrics: \"\",\r\n        \"x-id\": \"GetBucketMetricsConfiguration\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketNotificationConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        notification: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketPolicyCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        policy: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketPolicyStatusCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        policyStatus: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketReplicationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        replication: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketRequestPaymentCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        requestPayment: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketVersioningCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        versioning: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetBucketWebsiteCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        website: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.IfNoneMatch) && { \"If-None-Match\": input.IfNoneMatch }),\r\n        ...(isSerializableHeaderValue(input.IfMatch) && { \"If-Match\": input.IfMatch }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.Range) && { Range: input.Range }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.IfModifiedSince) && {\r\n            \"If-Modified-Since\": __dateToUtcString(input.IfModifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.IfUnmodifiedSince) && {\r\n            \"If-Unmodified-Since\": __dateToUtcString(input.IfUnmodifiedSince).toString(),\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"GetObject\",\r\n        ...(input.ResponseContentDisposition !== undefined && {\r\n            \"response-content-disposition\": input.ResponseContentDisposition,\r\n        }),\r\n        ...(input.ResponseContentLanguage !== undefined && { \"response-content-language\": input.ResponseContentLanguage }),\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n        ...(input.ResponseContentEncoding !== undefined && { \"response-content-encoding\": input.ResponseContentEncoding }),\r\n        ...(input.ResponseCacheControl !== undefined && { \"response-cache-control\": input.ResponseCacheControl }),\r\n        ...(input.ResponseExpires !== undefined && {\r\n            \"response-expires\": (input.ResponseExpires.toISOString().split(\".\")[0] + \"Z\").toString(),\r\n        }),\r\n        ...(input.ResponseContentType !== undefined && { \"response-content-type\": input.ResponseContentType }),\r\n        ...(input.PartNumber !== undefined && { partNumber: input.PartNumber.toString() }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectAclCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        acl: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectLegalHoldCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"legal-hold\": \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectLockConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"object-lock\": \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectRetentionCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        retention: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetObjectTorrentCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        torrent: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlGetPublicAccessBlockCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        publicAccessBlock: \"\",\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlHeadBucketCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"HEAD\",\r\n        headers,\r\n        path: resolvedPath,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlHeadObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.Range) && { Range: input.Range }),\r\n        ...(isSerializableHeaderValue(input.IfUnmodifiedSince) && {\r\n            \"If-Unmodified-Since\": __dateToUtcString(input.IfUnmodifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.IfNoneMatch) && { \"If-None-Match\": input.IfNoneMatch }),\r\n        ...(isSerializableHeaderValue(input.IfModifiedSince) && {\r\n            \"If-Modified-Since\": __dateToUtcString(input.IfModifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.IfMatch) && { \"If-Match\": input.IfMatch }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        ...(input.PartNumber !== undefined && { partNumber: input.PartNumber.toString() }),\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"HEAD\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListBucketAnalyticsConfigurationsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        analytics: \"\",\r\n        \"x-id\": \"ListBucketAnalyticsConfigurations\",\r\n        ...(input.ContinuationToken !== undefined && { \"continuation-token\": input.ContinuationToken }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListBucketInventoryConfigurationsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        inventory: \"\",\r\n        \"x-id\": \"ListBucketInventoryConfigurations\",\r\n        ...(input.ContinuationToken !== undefined && { \"continuation-token\": input.ContinuationToken }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListBucketMetricsConfigurationsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        metrics: \"\",\r\n        \"x-id\": \"ListBucketMetricsConfigurations\",\r\n        ...(input.ContinuationToken !== undefined && { \"continuation-token\": input.ContinuationToken }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListBucketsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/\";\r\n    let body;\r\n    body = \"\";\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListMultipartUploadsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        uploads: \"\",\r\n        ...(input.Delimiter !== undefined && { delimiter: input.Delimiter }),\r\n        ...(input.EncodingType !== undefined && { \"encoding-type\": input.EncodingType }),\r\n        ...(input.Prefix !== undefined && { prefix: input.Prefix }),\r\n        ...(input.KeyMarker !== undefined && { \"key-marker\": input.KeyMarker }),\r\n        ...(input.UploadIdMarker !== undefined && { \"upload-id-marker\": input.UploadIdMarker }),\r\n        ...(input.MaxUploads !== undefined && { \"max-uploads\": input.MaxUploads.toString() }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListObjectsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        ...(input.Marker !== undefined && { marker: input.Marker }),\r\n        ...(input.Prefix !== undefined && { prefix: input.Prefix }),\r\n        ...(input.EncodingType !== undefined && { \"encoding-type\": input.EncodingType }),\r\n        ...(input.MaxKeys !== undefined && { \"max-keys\": input.MaxKeys.toString() }),\r\n        ...(input.Delimiter !== undefined && { delimiter: input.Delimiter }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListObjectsV2Command = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"list-type\": \"2\",\r\n        ...(input.MaxKeys !== undefined && { \"max-keys\": input.MaxKeys.toString() }),\r\n        ...(input.StartAfter !== undefined && { \"start-after\": input.StartAfter }),\r\n        ...(input.FetchOwner !== undefined && { \"fetch-owner\": input.FetchOwner.toString() }),\r\n        ...(input.Prefix !== undefined && { prefix: input.Prefix }),\r\n        ...(input.Delimiter !== undefined && { delimiter: input.Delimiter }),\r\n        ...(input.ContinuationToken !== undefined && { \"continuation-token\": input.ContinuationToken }),\r\n        ...(input.EncodingType !== undefined && { \"encoding-type\": input.EncodingType }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListObjectVersionsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        versions: \"\",\r\n        ...(input.Prefix !== undefined && { prefix: input.Prefix }),\r\n        ...(input.EncodingType !== undefined && { \"encoding-type\": input.EncodingType }),\r\n        ...(input.KeyMarker !== undefined && { \"key-marker\": input.KeyMarker }),\r\n        ...(input.MaxKeys !== undefined && { \"max-keys\": input.MaxKeys.toString() }),\r\n        ...(input.VersionIdMarker !== undefined && { \"version-id-marker\": input.VersionIdMarker }),\r\n        ...(input.Delimiter !== undefined && { delimiter: input.Delimiter }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlListPartsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"ListParts\",\r\n        ...(input.PartNumberMarker !== undefined && { \"part-number-marker\": input.PartNumberMarker.toString() }),\r\n        ...(input.MaxParts !== undefined && { \"max-parts\": input.MaxParts.toString() }),\r\n        ...(input.UploadId !== undefined && { uploadId: input.UploadId }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"GET\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketAccelerateConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        accelerate: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.AccelerateConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlAccelerateConfiguration(input.AccelerateConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketAclCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n        ...(isSerializableHeaderValue(input.GrantWrite) && { \"x-amz-grant-write\": input.GrantWrite }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        acl: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.AccessControlPolicy !== undefined) {\r\n        contents = serializeAws_restXmlAccessControlPolicy(input.AccessControlPolicy, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketAnalyticsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        analytics: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.AnalyticsConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlAnalyticsConfiguration(input.AnalyticsConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketCorsCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        cors: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.CORSConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlCORSConfiguration(input.CORSConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketEncryptionCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        encryption: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.ServerSideEncryptionConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketInventoryConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        inventory: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.InventoryConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlInventoryConfiguration(input.InventoryConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketLifecycleConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        lifecycle: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.LifecycleConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlBucketLifecycleConfiguration(input.LifecycleConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketLoggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        logging: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.BucketLoggingStatus !== undefined) {\r\n        contents = serializeAws_restXmlBucketLoggingStatus(input.BucketLoggingStatus, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketMetricsConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        metrics: \"\",\r\n        ...(input.Id !== undefined && { id: input.Id }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.MetricsConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlMetricsConfiguration(input.MetricsConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketNotificationConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        notification: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.NotificationConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlNotificationConfiguration(input.NotificationConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketPolicyCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ConfirmRemoveSelfBucketAccess) && {\r\n            \"x-amz-confirm-remove-self-bucket-access\": input.ConfirmRemoveSelfBucketAccess.toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        policy: \"\",\r\n    };\r\n    let body;\r\n    body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n    const bodyNode = new __XmlNode(\"PutBucketPolicyRequest\");\r\n    bodyNode.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n    if (input.Policy !== undefined) {\r\n        const node = new __XmlNode(\"Policy\").addChildNode(new __XmlText(input.Policy)).withName(\"Policy\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    body += bodyNode.toString();\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketReplicationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.Token) && { \"x-amz-bucket-object-lock-token\": input.Token }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        replication: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.ReplicationConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlReplicationConfiguration(input.ReplicationConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketRequestPaymentCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        requestPayment: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.RequestPaymentConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlRequestPaymentConfiguration(input.RequestPaymentConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Tagging !== undefined) {\r\n        contents = serializeAws_restXmlTagging(input.Tagging, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketVersioningCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.MFA) && { \"x-amz-mfa\": input.MFA }),\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        versioning: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.VersioningConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlVersioningConfiguration(input.VersioningConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutBucketWebsiteCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        website: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.WebsiteConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlWebsiteConfiguration(input.WebsiteConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/octet-stream\",\r\n        ...(isSerializableHeaderValue(input.StorageClass) && { \"x-amz-storage-class\": input.StorageClass }),\r\n        ...(isSerializableHeaderValue(input.Tagging) && { \"x-amz-tagging\": input.Tagging }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSEncryptionContext) && {\r\n            \"x-amz-server-side-encryption-context\": input.SSEKMSEncryptionContext,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.WebsiteRedirectLocation) && {\r\n            \"x-amz-website-redirect-location\": input.WebsiteRedirectLocation,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ServerSideEncryption) && {\r\n            \"x-amz-server-side-encryption\": input.ServerSideEncryption,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.Expires) && { Expires: __dateToUtcString(input.Expires).toString() }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n        ...(isSerializableHeaderValue(input.ContentDisposition) && { \"Content-Disposition\": input.ContentDisposition }),\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockLegalHoldStatus) && {\r\n            \"x-amz-object-lock-legal-hold\": input.ObjectLockLegalHoldStatus,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ContentEncoding) && { \"Content-Encoding\": input.ContentEncoding }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockRetainUntilDate) && {\r\n            \"x-amz-object-lock-retain-until-date\": (input.ObjectLockRetainUntilDate.toISOString().split(\".\")[0] + \"Z\").toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CacheControl) && { \"Cache-Control\": input.CacheControl }),\r\n        ...(isSerializableHeaderValue(input.ContentLength) && { \"Content-Length\": input.ContentLength.toString() }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSEKMSKeyId) && {\r\n            \"x-amz-server-side-encryption-aws-kms-key-id\": input.SSEKMSKeyId,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.ObjectLockMode) && { \"x-amz-object-lock-mode\": input.ObjectLockMode }),\r\n        ...(isSerializableHeaderValue(input.ContentLanguage) && { \"Content-Language\": input.ContentLanguage }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n        ...(isSerializableHeaderValue(input.ContentType) && { \"Content-Type\": input.ContentType }),\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(input.Metadata !== undefined &&\r\n            Object.keys(input.Metadata).reduce((acc, suffix) => {\r\n                acc[\"x-amz-meta-\" + suffix] = input.Metadata[suffix];\r\n                return acc;\r\n            }, {})),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"PutObject\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Body !== undefined) {\r\n        contents = input.Body;\r\n        body = contents;\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectAclCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.GrantReadACP) && { \"x-amz-grant-read-acp\": input.GrantReadACP }),\r\n        ...(isSerializableHeaderValue(input.GrantFullControl) && { \"x-amz-grant-full-control\": input.GrantFullControl }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.GrantRead) && { \"x-amz-grant-read\": input.GrantRead }),\r\n        ...(isSerializableHeaderValue(input.GrantWriteACP) && { \"x-amz-grant-write-acp\": input.GrantWriteACP }),\r\n        ...(isSerializableHeaderValue(input.GrantWrite) && { \"x-amz-grant-write\": input.GrantWrite }),\r\n        ...(isSerializableHeaderValue(input.ACL) && { \"x-amz-acl\": input.ACL }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        acl: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.AccessControlPolicy !== undefined) {\r\n        contents = serializeAws_restXmlAccessControlPolicy(input.AccessControlPolicy, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectLegalHoldCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"legal-hold\": \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.LegalHold !== undefined) {\r\n        contents = serializeAws_restXmlObjectLockLegalHold(input.LegalHold, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectLockConfigurationCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.Token) && { \"x-amz-bucket-object-lock-token\": input.Token }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        \"object-lock\": \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.ObjectLockConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlObjectLockConfiguration(input.ObjectLockConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectRetentionCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.BypassGovernanceRetention) && {\r\n            \"x-amz-bypass-governance-retention\": input.BypassGovernanceRetention.toString(),\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        retention: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Retention !== undefined) {\r\n        contents = serializeAws_restXmlObjectLockRetention(input.Retention, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutObjectTaggingCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        tagging: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Tagging !== undefined) {\r\n        contents = serializeAws_restXmlTagging(input.Tagging, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlPutPublicAccessBlockCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        publicAccessBlock: \"\",\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.PublicAccessBlockConfiguration !== undefined) {\r\n        contents = serializeAws_restXmlPublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlRestoreObjectCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        restore: \"\",\r\n        ...(input.VersionId !== undefined && { versionId: input.VersionId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.RestoreRequest !== undefined) {\r\n        contents = serializeAws_restXmlRestoreRequest(input.RestoreRequest, context);\r\n        body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n        contents.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n        body += contents.toString();\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"POST\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlSelectObjectContentCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    const query = {\r\n        select: \"\",\r\n        \"select-type\": \"2\",\r\n    };\r\n    let body;\r\n    body = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\r\n    const bodyNode = new __XmlNode(\"SelectObjectContentRequest\");\r\n    bodyNode.addAttribute(\"xmlns\", \"http://s3.amazonaws.com/doc/2006-03-01/\");\r\n    if (input.Expression !== undefined) {\r\n        const node = new __XmlNode(\"Expression\").addChildNode(new __XmlText(input.Expression)).withName(\"Expression\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ExpressionType !== undefined) {\r\n        const node = new __XmlNode(\"ExpressionType\")\r\n            .addChildNode(new __XmlText(input.ExpressionType))\r\n            .withName(\"ExpressionType\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.InputSerialization !== undefined) {\r\n        const node = serializeAws_restXmlInputSerialization(input.InputSerialization, context).withName(\"InputSerialization\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.OutputSerialization !== undefined) {\r\n        const node = serializeAws_restXmlOutputSerialization(input.OutputSerialization, context).withName(\"OutputSerialization\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.RequestProgress !== undefined) {\r\n        const node = serializeAws_restXmlRequestProgress(input.RequestProgress, context).withName(\"RequestProgress\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ScanRange !== undefined) {\r\n        const node = serializeAws_restXmlScanRange(input.ScanRange, context).withName(\"ScanRange\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    body += bodyNode.toString();\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"POST\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlUploadPartCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"application/octet-stream\",\r\n        ...(isSerializableHeaderValue(input.ContentLength) && { \"Content-Length\": input.ContentLength.toString() }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.ContentMD5) && { \"Content-MD5\": input.ContentMD5 }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"UploadPart\",\r\n        ...(input.PartNumber !== undefined && { partNumber: input.PartNumber.toString() }),\r\n        ...(input.UploadId !== undefined && { uploadId: input.UploadId }),\r\n    };\r\n    let body;\r\n    let contents;\r\n    if (input.Body !== undefined) {\r\n        contents = input.Body;\r\n        body = contents;\r\n    }\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const serializeAws_restXmlUploadPartCopyCommand = async (input, context) => {\r\n    const headers = {\r\n        \"Content-Type\": \"\",\r\n        ...(isSerializableHeaderValue(input.RequestPayer) && { \"x-amz-request-payer\": input.RequestPayer }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKeyMD5) && {\r\n            \"x-amz-server-side-encryption-customer-key-MD5\": input.SSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfUnmodifiedSince) && {\r\n            \"x-amz-copy-source-if-unmodified-since\": __dateToUtcString(input.CopySourceIfUnmodifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfNoneMatch) && {\r\n            \"x-amz-copy-source-if-none-match\": input.CopySourceIfNoneMatch,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfMatch) && {\r\n            \"x-amz-copy-source-if-match\": input.CopySourceIfMatch,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerKeyMD5) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-key-MD5\": input.CopySourceSSECustomerKeyMD5,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerKey) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-key\": input.CopySourceSSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceSSECustomerAlgorithm) && {\r\n            \"x-amz-copy-source-server-side-encryption-customer-algorithm\": input.CopySourceSSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceIfModifiedSince) && {\r\n            \"x-amz-copy-source-if-modified-since\": __dateToUtcString(input.CopySourceIfModifiedSince).toString(),\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerAlgorithm) && {\r\n            \"x-amz-server-side-encryption-customer-algorithm\": input.SSECustomerAlgorithm,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.SSECustomerKey) && {\r\n            \"x-amz-server-side-encryption-customer-key\": input.SSECustomerKey,\r\n        }),\r\n        ...(isSerializableHeaderValue(input.CopySourceRange) && { \"x-amz-copy-source-range\": input.CopySourceRange }),\r\n        ...(isSerializableHeaderValue(input.CopySource) && { \"x-amz-copy-source\": input.CopySource }),\r\n    };\r\n    let resolvedPath = \"/{Bucket}/{Key+}\";\r\n    if (input.Bucket !== undefined) {\r\n        const labelValue = input.Bucket;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Bucket.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Bucket}\", __extendedEncodeURIComponent(labelValue));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Bucket.\");\r\n    }\r\n    if (input.Key !== undefined) {\r\n        const labelValue = input.Key;\r\n        if (labelValue.length <= 0) {\r\n            throw new Error(\"Empty value provided for input HTTP label: Key.\");\r\n        }\r\n        resolvedPath = resolvedPath.replace(\"{Key+}\", labelValue\r\n            .split(\"/\")\r\n            .map((segment) => __extendedEncodeURIComponent(segment))\r\n            .join(\"/\"));\r\n    }\r\n    else {\r\n        throw new Error(\"No value provided for input HTTP label: Key.\");\r\n    }\r\n    const query = {\r\n        \"x-id\": \"UploadPartCopy\",\r\n        ...(input.UploadId !== undefined && { uploadId: input.UploadId }),\r\n        ...(input.PartNumber !== undefined && { partNumber: input.PartNumber.toString() }),\r\n    };\r\n    let body;\r\n    const { hostname, protocol = \"https\", port } = await context.endpoint();\r\n    return new __HttpRequest({\r\n        protocol,\r\n        hostname,\r\n        port,\r\n        method: \"PUT\",\r\n        headers,\r\n        path: resolvedPath,\r\n        query,\r\n        body,\r\n    });\r\n};\r\nexport const deserializeAws_restXmlAbortMultipartUploadCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlAbortMultipartUploadCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"AbortMultipartUploadOutput\",\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlAbortMultipartUploadCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchUpload\":\r\n        case \"com.amazonaws.s3#NoSuchUpload\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchUploadResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlCompleteMultipartUploadCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlCompleteMultipartUploadCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"CompleteMultipartUploadOutput\",\r\n        Bucket: undefined,\r\n        ETag: undefined,\r\n        Expiration: undefined,\r\n        Key: undefined,\r\n        Location: undefined,\r\n        RequestCharged: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-expiration\"] !== undefined) {\r\n        contents.Expiration = output.headers[\"x-amz-expiration\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = data[\"Bucket\"];\r\n    }\r\n    if (data[\"ETag\"] !== undefined) {\r\n        contents.ETag = data[\"ETag\"];\r\n    }\r\n    if (data[\"Key\"] !== undefined) {\r\n        contents.Key = data[\"Key\"];\r\n    }\r\n    if (data[\"Location\"] !== undefined) {\r\n        contents.Location = data[\"Location\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlCompleteMultipartUploadCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlCopyObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlCopyObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"CopyObjectOutput\",\r\n        CopyObjectResult: undefined,\r\n        CopySourceVersionId: undefined,\r\n        Expiration: undefined,\r\n        RequestCharged: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSEncryptionContext: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-copy-source-version-id\"] !== undefined) {\r\n        contents.CopySourceVersionId = output.headers[\"x-amz-copy-source-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-context\"] !== undefined) {\r\n        contents.SSEKMSEncryptionContext = output.headers[\"x-amz-server-side-encryption-context\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-expiration\"] !== undefined) {\r\n        contents.Expiration = output.headers[\"x-amz-expiration\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    contents.CopyObjectResult = deserializeAws_restXmlCopyObjectResult(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlCopyObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"ObjectNotInActiveTierError\":\r\n        case \"com.amazonaws.s3#ObjectNotInActiveTierError\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlObjectNotInActiveTierErrorResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlCreateBucketCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlCreateBucketCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"CreateBucketOutput\",\r\n        Location: undefined,\r\n    };\r\n    if (output.headers[\"location\"] !== undefined) {\r\n        contents.Location = output.headers[\"location\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlCreateBucketCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"BucketAlreadyExists\":\r\n        case \"com.amazonaws.s3#BucketAlreadyExists\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlBucketAlreadyExistsResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        case \"BucketAlreadyOwnedByYou\":\r\n        case \"com.amazonaws.s3#BucketAlreadyOwnedByYou\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlBucketAlreadyOwnedByYouResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlCreateMultipartUploadCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlCreateMultipartUploadCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"CreateMultipartUploadOutput\",\r\n        AbortDate: undefined,\r\n        AbortRuleId: undefined,\r\n        Bucket: undefined,\r\n        Key: undefined,\r\n        RequestCharged: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSEncryptionContext: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        UploadId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-context\"] !== undefined) {\r\n        contents.SSEKMSEncryptionContext = output.headers[\"x-amz-server-side-encryption-context\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    if (output.headers[\"x-amz-abort-rule-id\"] !== undefined) {\r\n        contents.AbortRuleId = output.headers[\"x-amz-abort-rule-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-abort-date\"] !== undefined) {\r\n        contents.AbortDate = new Date(output.headers[\"x-amz-abort-date\"]);\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = data[\"Bucket\"];\r\n    }\r\n    if (data[\"Key\"] !== undefined) {\r\n        contents.Key = data[\"Key\"];\r\n    }\r\n    if (data[\"UploadId\"] !== undefined) {\r\n        contents.UploadId = data[\"UploadId\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlCreateMultipartUploadCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketCorsCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketCorsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketCorsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketEncryptionCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketEncryptionCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketEncryptionCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketInventoryConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketInventoryConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketInventoryConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketLifecycleCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketLifecycleCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketLifecycleCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketMetricsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketMetricsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketMetricsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketPolicyCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketPolicyCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketPolicyCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketReplicationCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketReplicationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketReplicationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteBucketWebsiteCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteBucketWebsiteCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteBucketWebsiteCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"DeleteObjectOutput\",\r\n        DeleteMarker: undefined,\r\n        RequestCharged: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-delete-marker\"] !== undefined) {\r\n        contents.DeleteMarker = output.headers[\"x-amz-delete-marker\"] === \"true\";\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteObjectsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteObjectsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"DeleteObjectsOutput\",\r\n        Deleted: undefined,\r\n        Errors: undefined,\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data.Deleted === \"\") {\r\n        contents.Deleted = [];\r\n    }\r\n    if (data[\"Deleted\"] !== undefined) {\r\n        contents.Deleted = deserializeAws_restXmlDeletedObjects(__getArrayIfSingleItem(data[\"Deleted\"]), context);\r\n    }\r\n    if (data.Error === \"\") {\r\n        contents.Errors = [];\r\n    }\r\n    if (data[\"Error\"] !== undefined) {\r\n        contents.Errors = deserializeAws_restXmlErrors(__getArrayIfSingleItem(data[\"Error\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteObjectsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeleteObjectTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeleteObjectTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"DeleteObjectTaggingOutput\",\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeleteObjectTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlDeletePublicAccessBlockCommand = async (output, context) => {\r\n    if (output.statusCode !== 204 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlDeletePublicAccessBlockCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlDeletePublicAccessBlockCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketAccelerateConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketAccelerateConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketAccelerateConfigurationOutput\",\r\n        Status: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Status\"] !== undefined) {\r\n        contents.Status = data[\"Status\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketAccelerateConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketAclCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketAclCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketAclOutput\",\r\n        Grants: undefined,\r\n        Owner: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.AccessControlList === \"\") {\r\n        contents.Grants = [];\r\n    }\r\n    if (data[\"AccessControlList\"] !== undefined && data[\"AccessControlList\"][\"Grant\"] !== undefined) {\r\n        contents.Grants = deserializeAws_restXmlGrants(__getArrayIfSingleItem(data[\"AccessControlList\"][\"Grant\"]), context);\r\n    }\r\n    if (data[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(data[\"Owner\"], context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketAclCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketAnalyticsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketAnalyticsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketAnalyticsConfigurationOutput\",\r\n        AnalyticsConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.AnalyticsConfiguration = deserializeAws_restXmlAnalyticsConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketAnalyticsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketCorsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketCorsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketCorsOutput\",\r\n        CORSRules: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.CORSRule === \"\") {\r\n        contents.CORSRules = [];\r\n    }\r\n    if (data[\"CORSRule\"] !== undefined) {\r\n        contents.CORSRules = deserializeAws_restXmlCORSRules(__getArrayIfSingleItem(data[\"CORSRule\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketCorsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketEncryptionCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketEncryptionCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketEncryptionOutput\",\r\n        ServerSideEncryptionConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.ServerSideEncryptionConfiguration = deserializeAws_restXmlServerSideEncryptionConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketEncryptionCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketInventoryConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketInventoryConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketInventoryConfigurationOutput\",\r\n        InventoryConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.InventoryConfiguration = deserializeAws_restXmlInventoryConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketInventoryConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketLifecycleConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketLifecycleConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketLifecycleConfigurationOutput\",\r\n        Rules: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.Rule === \"\") {\r\n        contents.Rules = [];\r\n    }\r\n    if (data[\"Rule\"] !== undefined) {\r\n        contents.Rules = deserializeAws_restXmlLifecycleRules(__getArrayIfSingleItem(data[\"Rule\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketLifecycleConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketLocationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketLocationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketLocationOutput\",\r\n        LocationConstraint: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"LocationConstraint\"] !== undefined) {\r\n        contents.LocationConstraint = data[\"LocationConstraint\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketLocationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketLoggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketLoggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketLoggingOutput\",\r\n        LoggingEnabled: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"LoggingEnabled\"] !== undefined) {\r\n        contents.LoggingEnabled = deserializeAws_restXmlLoggingEnabled(data[\"LoggingEnabled\"], context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketLoggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketMetricsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketMetricsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketMetricsConfigurationOutput\",\r\n        MetricsConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.MetricsConfiguration = deserializeAws_restXmlMetricsConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketMetricsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketNotificationConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketNotificationConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"NotificationConfiguration\",\r\n        LambdaFunctionConfigurations: undefined,\r\n        QueueConfigurations: undefined,\r\n        TopicConfigurations: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.CloudFunctionConfiguration === \"\") {\r\n        contents.LambdaFunctionConfigurations = [];\r\n    }\r\n    if (data[\"CloudFunctionConfiguration\"] !== undefined) {\r\n        contents.LambdaFunctionConfigurations = deserializeAws_restXmlLambdaFunctionConfigurationList(__getArrayIfSingleItem(data[\"CloudFunctionConfiguration\"]), context);\r\n    }\r\n    if (data.QueueConfiguration === \"\") {\r\n        contents.QueueConfigurations = [];\r\n    }\r\n    if (data[\"QueueConfiguration\"] !== undefined) {\r\n        contents.QueueConfigurations = deserializeAws_restXmlQueueConfigurationList(__getArrayIfSingleItem(data[\"QueueConfiguration\"]), context);\r\n    }\r\n    if (data.TopicConfiguration === \"\") {\r\n        contents.TopicConfigurations = [];\r\n    }\r\n    if (data[\"TopicConfiguration\"] !== undefined) {\r\n        contents.TopicConfigurations = deserializeAws_restXmlTopicConfigurationList(__getArrayIfSingleItem(data[\"TopicConfiguration\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketNotificationConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketPolicyCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketPolicyCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketPolicyOutput\",\r\n        Policy: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Policy\"] !== undefined) {\r\n        contents.Policy = data[\"Policy\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketPolicyCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketPolicyStatusCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketPolicyStatusCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketPolicyStatusOutput\",\r\n        PolicyStatus: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.PolicyStatus = deserializeAws_restXmlPolicyStatus(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketPolicyStatusCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketReplicationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketReplicationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketReplicationOutput\",\r\n        ReplicationConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.ReplicationConfiguration = deserializeAws_restXmlReplicationConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketReplicationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketRequestPaymentCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketRequestPaymentCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketRequestPaymentOutput\",\r\n        Payer: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Payer\"] !== undefined) {\r\n        contents.Payer = data[\"Payer\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketRequestPaymentCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketTaggingOutput\",\r\n        TagSet: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.TagSet === \"\") {\r\n        contents.TagSet = [];\r\n    }\r\n    if (data[\"TagSet\"] !== undefined && data[\"TagSet\"][\"Tag\"] !== undefined) {\r\n        contents.TagSet = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(data[\"TagSet\"][\"Tag\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketVersioningCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketVersioningCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketVersioningOutput\",\r\n        MFADelete: undefined,\r\n        Status: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"MfaDelete\"] !== undefined) {\r\n        contents.MFADelete = data[\"MfaDelete\"];\r\n    }\r\n    if (data[\"Status\"] !== undefined) {\r\n        contents.Status = data[\"Status\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketVersioningCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetBucketWebsiteCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetBucketWebsiteCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetBucketWebsiteOutput\",\r\n        ErrorDocument: undefined,\r\n        IndexDocument: undefined,\r\n        RedirectAllRequestsTo: undefined,\r\n        RoutingRules: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"ErrorDocument\"] !== undefined) {\r\n        contents.ErrorDocument = deserializeAws_restXmlErrorDocument(data[\"ErrorDocument\"], context);\r\n    }\r\n    if (data[\"IndexDocument\"] !== undefined) {\r\n        contents.IndexDocument = deserializeAws_restXmlIndexDocument(data[\"IndexDocument\"], context);\r\n    }\r\n    if (data[\"RedirectAllRequestsTo\"] !== undefined) {\r\n        contents.RedirectAllRequestsTo = deserializeAws_restXmlRedirectAllRequestsTo(data[\"RedirectAllRequestsTo\"], context);\r\n    }\r\n    if (data.RoutingRules === \"\") {\r\n        contents.RoutingRules = [];\r\n    }\r\n    if (data[\"RoutingRules\"] !== undefined && data[\"RoutingRules\"][\"RoutingRule\"] !== undefined) {\r\n        contents.RoutingRules = deserializeAws_restXmlRoutingRules(__getArrayIfSingleItem(data[\"RoutingRules\"][\"RoutingRule\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetBucketWebsiteCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectOutput\",\r\n        AcceptRanges: undefined,\r\n        Body: undefined,\r\n        CacheControl: undefined,\r\n        ContentDisposition: undefined,\r\n        ContentEncoding: undefined,\r\n        ContentLanguage: undefined,\r\n        ContentLength: undefined,\r\n        ContentRange: undefined,\r\n        ContentType: undefined,\r\n        DeleteMarker: undefined,\r\n        ETag: undefined,\r\n        Expiration: undefined,\r\n        Expires: undefined,\r\n        LastModified: undefined,\r\n        Metadata: undefined,\r\n        MissingMeta: undefined,\r\n        ObjectLockLegalHoldStatus: undefined,\r\n        ObjectLockMode: undefined,\r\n        ObjectLockRetainUntilDate: undefined,\r\n        PartsCount: undefined,\r\n        ReplicationStatus: undefined,\r\n        RequestCharged: undefined,\r\n        Restore: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        StorageClass: undefined,\r\n        TagCount: undefined,\r\n        VersionId: undefined,\r\n        WebsiteRedirectLocation: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-restore\"] !== undefined) {\r\n        contents.Restore = output.headers[\"x-amz-restore\"];\r\n    }\r\n    if (output.headers[\"last-modified\"] !== undefined) {\r\n        contents.LastModified = new Date(output.headers[\"last-modified\"]);\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-mp-parts-count\"] !== undefined) {\r\n        contents.PartsCount = parseInt(output.headers[\"x-amz-mp-parts-count\"], 10);\r\n    }\r\n    if (output.headers[\"content-range\"] !== undefined) {\r\n        contents.ContentRange = output.headers[\"content-range\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-mode\"] !== undefined) {\r\n        contents.ObjectLockMode = output.headers[\"x-amz-object-lock-mode\"];\r\n    }\r\n    if (output.headers[\"accept-ranges\"] !== undefined) {\r\n        contents.AcceptRanges = output.headers[\"accept-ranges\"];\r\n    }\r\n    if (output.headers[\"content-encoding\"] !== undefined) {\r\n        contents.ContentEncoding = output.headers[\"content-encoding\"];\r\n    }\r\n    if (output.headers[\"x-amz-storage-class\"] !== undefined) {\r\n        contents.StorageClass = output.headers[\"x-amz-storage-class\"];\r\n    }\r\n    if (output.headers[\"x-amz-tagging-count\"] !== undefined) {\r\n        contents.TagCount = parseInt(output.headers[\"x-amz-tagging-count\"], 10);\r\n    }\r\n    if (output.headers[\"x-amz-delete-marker\"] !== undefined) {\r\n        contents.DeleteMarker = output.headers[\"x-amz-delete-marker\"] === \"true\";\r\n    }\r\n    if (output.headers[\"x-amz-missing-meta\"] !== undefined) {\r\n        contents.MissingMeta = parseInt(output.headers[\"x-amz-missing-meta\"], 10);\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-retain-until-date\"] !== undefined) {\r\n        contents.ObjectLockRetainUntilDate = new Date(output.headers[\"x-amz-object-lock-retain-until-date\"]);\r\n    }\r\n    if (output.headers[\"content-language\"] !== undefined) {\r\n        contents.ContentLanguage = output.headers[\"content-language\"];\r\n    }\r\n    if (output.headers[\"expires\"] !== undefined) {\r\n        contents.Expires = new Date(output.headers[\"expires\"]);\r\n    }\r\n    if (output.headers[\"content-length\"] !== undefined) {\r\n        contents.ContentLength = parseInt(output.headers[\"content-length\"], 10);\r\n    }\r\n    if (output.headers[\"content-disposition\"] !== undefined) {\r\n        contents.ContentDisposition = output.headers[\"content-disposition\"];\r\n    }\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-legal-hold\"] !== undefined) {\r\n        contents.ObjectLockLegalHoldStatus = output.headers[\"x-amz-object-lock-legal-hold\"];\r\n    }\r\n    if (output.headers[\"content-type\"] !== undefined) {\r\n        contents.ContentType = output.headers[\"content-type\"];\r\n    }\r\n    if (output.headers[\"cache-control\"] !== undefined) {\r\n        contents.CacheControl = output.headers[\"cache-control\"];\r\n    }\r\n    if (output.headers[\"x-amz-website-redirect-location\"] !== undefined) {\r\n        contents.WebsiteRedirectLocation = output.headers[\"x-amz-website-redirect-location\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"etag\"] !== undefined) {\r\n        contents.ETag = output.headers[\"etag\"];\r\n    }\r\n    if (output.headers[\"x-amz-replication-status\"] !== undefined) {\r\n        contents.ReplicationStatus = output.headers[\"x-amz-replication-status\"];\r\n    }\r\n    if (output.headers[\"x-amz-expiration\"] !== undefined) {\r\n        contents.Expiration = output.headers[\"x-amz-expiration\"];\r\n    }\r\n    Object.keys(output.headers).forEach((header) => {\r\n        if (contents.Metadata === undefined) {\r\n            contents.Metadata = {};\r\n        }\r\n        if (header.startsWith(\"x-amz-meta-\")) {\r\n            contents.Metadata[header.substring(11)] = output.headers[header];\r\n        }\r\n    });\r\n    const data = output.body;\r\n    contents.Body = data;\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchKey\":\r\n        case \"com.amazonaws.s3#NoSuchKey\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchKeyResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectAclCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectAclCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectAclOutput\",\r\n        Grants: undefined,\r\n        Owner: undefined,\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data.AccessControlList === \"\") {\r\n        contents.Grants = [];\r\n    }\r\n    if (data[\"AccessControlList\"] !== undefined && data[\"AccessControlList\"][\"Grant\"] !== undefined) {\r\n        contents.Grants = deserializeAws_restXmlGrants(__getArrayIfSingleItem(data[\"AccessControlList\"][\"Grant\"]), context);\r\n    }\r\n    if (data[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(data[\"Owner\"], context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectAclCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchKey\":\r\n        case \"com.amazonaws.s3#NoSuchKey\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchKeyResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectLegalHoldCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectLegalHoldCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectLegalHoldOutput\",\r\n        LegalHold: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.LegalHold = deserializeAws_restXmlObjectLockLegalHold(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectLegalHoldCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectLockConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectLockConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectLockConfigurationOutput\",\r\n        ObjectLockConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.ObjectLockConfiguration = deserializeAws_restXmlObjectLockConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectLockConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectRetentionCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectRetentionCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectRetentionOutput\",\r\n        Retention: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.Retention = deserializeAws_restXmlObjectLockRetention(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectRetentionCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectTaggingOutput\",\r\n        TagSet: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data.TagSet === \"\") {\r\n        contents.TagSet = [];\r\n    }\r\n    if (data[\"TagSet\"] !== undefined && data[\"TagSet\"][\"Tag\"] !== undefined) {\r\n        contents.TagSet = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(data[\"TagSet\"][\"Tag\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetObjectTorrentCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetObjectTorrentCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetObjectTorrentOutput\",\r\n        Body: undefined,\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    const data = output.body;\r\n    contents.Body = data;\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetObjectTorrentCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlGetPublicAccessBlockCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlGetPublicAccessBlockCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"GetPublicAccessBlockOutput\",\r\n        PublicAccessBlockConfiguration: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    contents.PublicAccessBlockConfiguration = deserializeAws_restXmlPublicAccessBlockConfiguration(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlGetPublicAccessBlockCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlHeadBucketCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlHeadBucketCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlHeadBucketCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchBucket\":\r\n        case \"com.amazonaws.s3#NoSuchBucket\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchBucketResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlHeadObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlHeadObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"HeadObjectOutput\",\r\n        AcceptRanges: undefined,\r\n        CacheControl: undefined,\r\n        ContentDisposition: undefined,\r\n        ContentEncoding: undefined,\r\n        ContentLanguage: undefined,\r\n        ContentLength: undefined,\r\n        ContentType: undefined,\r\n        DeleteMarker: undefined,\r\n        ETag: undefined,\r\n        Expiration: undefined,\r\n        Expires: undefined,\r\n        LastModified: undefined,\r\n        Metadata: undefined,\r\n        MissingMeta: undefined,\r\n        ObjectLockLegalHoldStatus: undefined,\r\n        ObjectLockMode: undefined,\r\n        ObjectLockRetainUntilDate: undefined,\r\n        PartsCount: undefined,\r\n        ReplicationStatus: undefined,\r\n        RequestCharged: undefined,\r\n        Restore: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        StorageClass: undefined,\r\n        VersionId: undefined,\r\n        WebsiteRedirectLocation: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    if (output.headers[\"last-modified\"] !== undefined) {\r\n        contents.LastModified = new Date(output.headers[\"last-modified\"]);\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-mp-parts-count\"] !== undefined) {\r\n        contents.PartsCount = parseInt(output.headers[\"x-amz-mp-parts-count\"], 10);\r\n    }\r\n    if (output.headers[\"x-amz-replication-status\"] !== undefined) {\r\n        contents.ReplicationStatus = output.headers[\"x-amz-replication-status\"];\r\n    }\r\n    if (output.headers[\"x-amz-restore\"] !== undefined) {\r\n        contents.Restore = output.headers[\"x-amz-restore\"];\r\n    }\r\n    if (output.headers[\"content-encoding\"] !== undefined) {\r\n        contents.ContentEncoding = output.headers[\"content-encoding\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"cache-control\"] !== undefined) {\r\n        contents.CacheControl = output.headers[\"cache-control\"];\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-retain-until-date\"] !== undefined) {\r\n        contents.ObjectLockRetainUntilDate = new Date(output.headers[\"x-amz-object-lock-retain-until-date\"]);\r\n    }\r\n    if (output.headers[\"x-amz-website-redirect-location\"] !== undefined) {\r\n        contents.WebsiteRedirectLocation = output.headers[\"x-amz-website-redirect-location\"];\r\n    }\r\n    if (output.headers[\"content-length\"] !== undefined) {\r\n        contents.ContentLength = parseInt(output.headers[\"content-length\"], 10);\r\n    }\r\n    if (output.headers[\"expires\"] !== undefined) {\r\n        contents.Expires = new Date(output.headers[\"expires\"]);\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-legal-hold\"] !== undefined) {\r\n        contents.ObjectLockLegalHoldStatus = output.headers[\"x-amz-object-lock-legal-hold\"];\r\n    }\r\n    if (output.headers[\"x-amz-missing-meta\"] !== undefined) {\r\n        contents.MissingMeta = parseInt(output.headers[\"x-amz-missing-meta\"], 10);\r\n    }\r\n    if (output.headers[\"content-disposition\"] !== undefined) {\r\n        contents.ContentDisposition = output.headers[\"content-disposition\"];\r\n    }\r\n    if (output.headers[\"x-amz-delete-marker\"] !== undefined) {\r\n        contents.DeleteMarker = output.headers[\"x-amz-delete-marker\"] === \"true\";\r\n    }\r\n    if (output.headers[\"content-language\"] !== undefined) {\r\n        contents.ContentLanguage = output.headers[\"content-language\"];\r\n    }\r\n    if (output.headers[\"etag\"] !== undefined) {\r\n        contents.ETag = output.headers[\"etag\"];\r\n    }\r\n    if (output.headers[\"x-amz-expiration\"] !== undefined) {\r\n        contents.Expiration = output.headers[\"x-amz-expiration\"];\r\n    }\r\n    if (output.headers[\"accept-ranges\"] !== undefined) {\r\n        contents.AcceptRanges = output.headers[\"accept-ranges\"];\r\n    }\r\n    if (output.headers[\"x-amz-object-lock-mode\"] !== undefined) {\r\n        contents.ObjectLockMode = output.headers[\"x-amz-object-lock-mode\"];\r\n    }\r\n    if (output.headers[\"content-type\"] !== undefined) {\r\n        contents.ContentType = output.headers[\"content-type\"];\r\n    }\r\n    if (output.headers[\"x-amz-storage-class\"] !== undefined) {\r\n        contents.StorageClass = output.headers[\"x-amz-storage-class\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    Object.keys(output.headers).forEach((header) => {\r\n        if (contents.Metadata === undefined) {\r\n            contents.Metadata = {};\r\n        }\r\n        if (header.startsWith(\"x-amz-meta-\")) {\r\n            contents.Metadata[header.substring(11)] = output.headers[header];\r\n        }\r\n    });\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlHeadObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchKey\":\r\n        case \"com.amazonaws.s3#NoSuchKey\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchKeyResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListBucketAnalyticsConfigurationsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListBucketAnalyticsConfigurationsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListBucketAnalyticsConfigurationsOutput\",\r\n        AnalyticsConfigurationList: undefined,\r\n        ContinuationToken: undefined,\r\n        IsTruncated: undefined,\r\n        NextContinuationToken: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.AnalyticsConfiguration === \"\") {\r\n        contents.AnalyticsConfigurationList = [];\r\n    }\r\n    if (data[\"AnalyticsConfiguration\"] !== undefined) {\r\n        contents.AnalyticsConfigurationList = deserializeAws_restXmlAnalyticsConfigurationList(__getArrayIfSingleItem(data[\"AnalyticsConfiguration\"]), context);\r\n    }\r\n    if (data[\"ContinuationToken\"] !== undefined) {\r\n        contents.ContinuationToken = data[\"ContinuationToken\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"NextContinuationToken\"] !== undefined) {\r\n        contents.NextContinuationToken = data[\"NextContinuationToken\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListBucketAnalyticsConfigurationsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListBucketInventoryConfigurationsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListBucketInventoryConfigurationsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListBucketInventoryConfigurationsOutput\",\r\n        ContinuationToken: undefined,\r\n        InventoryConfigurationList: undefined,\r\n        IsTruncated: undefined,\r\n        NextContinuationToken: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"ContinuationToken\"] !== undefined) {\r\n        contents.ContinuationToken = data[\"ContinuationToken\"];\r\n    }\r\n    if (data.InventoryConfiguration === \"\") {\r\n        contents.InventoryConfigurationList = [];\r\n    }\r\n    if (data[\"InventoryConfiguration\"] !== undefined) {\r\n        contents.InventoryConfigurationList = deserializeAws_restXmlInventoryConfigurationList(__getArrayIfSingleItem(data[\"InventoryConfiguration\"]), context);\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"NextContinuationToken\"] !== undefined) {\r\n        contents.NextContinuationToken = data[\"NextContinuationToken\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListBucketInventoryConfigurationsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListBucketMetricsConfigurationsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListBucketMetricsConfigurationsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListBucketMetricsConfigurationsOutput\",\r\n        ContinuationToken: undefined,\r\n        IsTruncated: undefined,\r\n        MetricsConfigurationList: undefined,\r\n        NextContinuationToken: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"ContinuationToken\"] !== undefined) {\r\n        contents.ContinuationToken = data[\"ContinuationToken\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data.MetricsConfiguration === \"\") {\r\n        contents.MetricsConfigurationList = [];\r\n    }\r\n    if (data[\"MetricsConfiguration\"] !== undefined) {\r\n        contents.MetricsConfigurationList = deserializeAws_restXmlMetricsConfigurationList(__getArrayIfSingleItem(data[\"MetricsConfiguration\"]), context);\r\n    }\r\n    if (data[\"NextContinuationToken\"] !== undefined) {\r\n        contents.NextContinuationToken = data[\"NextContinuationToken\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListBucketMetricsConfigurationsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListBucketsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListBucketsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListBucketsOutput\",\r\n        Buckets: undefined,\r\n        Owner: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.Buckets === \"\") {\r\n        contents.Buckets = [];\r\n    }\r\n    if (data[\"Buckets\"] !== undefined && data[\"Buckets\"][\"Bucket\"] !== undefined) {\r\n        contents.Buckets = deserializeAws_restXmlBuckets(__getArrayIfSingleItem(data[\"Buckets\"][\"Bucket\"]), context);\r\n    }\r\n    if (data[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(data[\"Owner\"], context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListBucketsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListMultipartUploadsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListMultipartUploadsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListMultipartUploadsOutput\",\r\n        Bucket: undefined,\r\n        CommonPrefixes: undefined,\r\n        Delimiter: undefined,\r\n        EncodingType: undefined,\r\n        IsTruncated: undefined,\r\n        KeyMarker: undefined,\r\n        MaxUploads: undefined,\r\n        NextKeyMarker: undefined,\r\n        NextUploadIdMarker: undefined,\r\n        Prefix: undefined,\r\n        UploadIdMarker: undefined,\r\n        Uploads: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = data[\"Bucket\"];\r\n    }\r\n    if (data.CommonPrefixes === \"\") {\r\n        contents.CommonPrefixes = [];\r\n    }\r\n    if (data[\"CommonPrefixes\"] !== undefined) {\r\n        contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(__getArrayIfSingleItem(data[\"CommonPrefixes\"]), context);\r\n    }\r\n    if (data[\"Delimiter\"] !== undefined) {\r\n        contents.Delimiter = data[\"Delimiter\"];\r\n    }\r\n    if (data[\"EncodingType\"] !== undefined) {\r\n        contents.EncodingType = data[\"EncodingType\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"KeyMarker\"] !== undefined) {\r\n        contents.KeyMarker = data[\"KeyMarker\"];\r\n    }\r\n    if (data[\"MaxUploads\"] !== undefined) {\r\n        contents.MaxUploads = parseInt(data[\"MaxUploads\"]);\r\n    }\r\n    if (data[\"NextKeyMarker\"] !== undefined) {\r\n        contents.NextKeyMarker = data[\"NextKeyMarker\"];\r\n    }\r\n    if (data[\"NextUploadIdMarker\"] !== undefined) {\r\n        contents.NextUploadIdMarker = data[\"NextUploadIdMarker\"];\r\n    }\r\n    if (data[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = data[\"Prefix\"];\r\n    }\r\n    if (data[\"UploadIdMarker\"] !== undefined) {\r\n        contents.UploadIdMarker = data[\"UploadIdMarker\"];\r\n    }\r\n    if (data.Upload === \"\") {\r\n        contents.Uploads = [];\r\n    }\r\n    if (data[\"Upload\"] !== undefined) {\r\n        contents.Uploads = deserializeAws_restXmlMultipartUploadList(__getArrayIfSingleItem(data[\"Upload\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListMultipartUploadsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListObjectsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListObjectsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListObjectsOutput\",\r\n        CommonPrefixes: undefined,\r\n        Contents: undefined,\r\n        Delimiter: undefined,\r\n        EncodingType: undefined,\r\n        IsTruncated: undefined,\r\n        Marker: undefined,\r\n        MaxKeys: undefined,\r\n        Name: undefined,\r\n        NextMarker: undefined,\r\n        Prefix: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.CommonPrefixes === \"\") {\r\n        contents.CommonPrefixes = [];\r\n    }\r\n    if (data[\"CommonPrefixes\"] !== undefined) {\r\n        contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(__getArrayIfSingleItem(data[\"CommonPrefixes\"]), context);\r\n    }\r\n    if (data.Contents === \"\") {\r\n        contents.Contents = [];\r\n    }\r\n    if (data[\"Contents\"] !== undefined) {\r\n        contents.Contents = deserializeAws_restXmlObjectList(__getArrayIfSingleItem(data[\"Contents\"]), context);\r\n    }\r\n    if (data[\"Delimiter\"] !== undefined) {\r\n        contents.Delimiter = data[\"Delimiter\"];\r\n    }\r\n    if (data[\"EncodingType\"] !== undefined) {\r\n        contents.EncodingType = data[\"EncodingType\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"Marker\"] !== undefined) {\r\n        contents.Marker = data[\"Marker\"];\r\n    }\r\n    if (data[\"MaxKeys\"] !== undefined) {\r\n        contents.MaxKeys = parseInt(data[\"MaxKeys\"]);\r\n    }\r\n    if (data[\"Name\"] !== undefined) {\r\n        contents.Name = data[\"Name\"];\r\n    }\r\n    if (data[\"NextMarker\"] !== undefined) {\r\n        contents.NextMarker = data[\"NextMarker\"];\r\n    }\r\n    if (data[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = data[\"Prefix\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListObjectsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchBucket\":\r\n        case \"com.amazonaws.s3#NoSuchBucket\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchBucketResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListObjectsV2Command = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListObjectsV2CommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListObjectsV2Output\",\r\n        CommonPrefixes: undefined,\r\n        Contents: undefined,\r\n        ContinuationToken: undefined,\r\n        Delimiter: undefined,\r\n        EncodingType: undefined,\r\n        IsTruncated: undefined,\r\n        KeyCount: undefined,\r\n        MaxKeys: undefined,\r\n        Name: undefined,\r\n        NextContinuationToken: undefined,\r\n        Prefix: undefined,\r\n        StartAfter: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.CommonPrefixes === \"\") {\r\n        contents.CommonPrefixes = [];\r\n    }\r\n    if (data[\"CommonPrefixes\"] !== undefined) {\r\n        contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(__getArrayIfSingleItem(data[\"CommonPrefixes\"]), context);\r\n    }\r\n    if (data.Contents === \"\") {\r\n        contents.Contents = [];\r\n    }\r\n    if (data[\"Contents\"] !== undefined) {\r\n        contents.Contents = deserializeAws_restXmlObjectList(__getArrayIfSingleItem(data[\"Contents\"]), context);\r\n    }\r\n    if (data[\"ContinuationToken\"] !== undefined) {\r\n        contents.ContinuationToken = data[\"ContinuationToken\"];\r\n    }\r\n    if (data[\"Delimiter\"] !== undefined) {\r\n        contents.Delimiter = data[\"Delimiter\"];\r\n    }\r\n    if (data[\"EncodingType\"] !== undefined) {\r\n        contents.EncodingType = data[\"EncodingType\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"KeyCount\"] !== undefined) {\r\n        contents.KeyCount = parseInt(data[\"KeyCount\"]);\r\n    }\r\n    if (data[\"MaxKeys\"] !== undefined) {\r\n        contents.MaxKeys = parseInt(data[\"MaxKeys\"]);\r\n    }\r\n    if (data[\"Name\"] !== undefined) {\r\n        contents.Name = data[\"Name\"];\r\n    }\r\n    if (data[\"NextContinuationToken\"] !== undefined) {\r\n        contents.NextContinuationToken = data[\"NextContinuationToken\"];\r\n    }\r\n    if (data[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = data[\"Prefix\"];\r\n    }\r\n    if (data[\"StartAfter\"] !== undefined) {\r\n        contents.StartAfter = data[\"StartAfter\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListObjectsV2CommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchBucket\":\r\n        case \"com.amazonaws.s3#NoSuchBucket\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchBucketResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListObjectVersionsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListObjectVersionsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListObjectVersionsOutput\",\r\n        CommonPrefixes: undefined,\r\n        DeleteMarkers: undefined,\r\n        Delimiter: undefined,\r\n        EncodingType: undefined,\r\n        IsTruncated: undefined,\r\n        KeyMarker: undefined,\r\n        MaxKeys: undefined,\r\n        Name: undefined,\r\n        NextKeyMarker: undefined,\r\n        NextVersionIdMarker: undefined,\r\n        Prefix: undefined,\r\n        VersionIdMarker: undefined,\r\n        Versions: undefined,\r\n    };\r\n    const data = await parseBody(output.body, context);\r\n    if (data.CommonPrefixes === \"\") {\r\n        contents.CommonPrefixes = [];\r\n    }\r\n    if (data[\"CommonPrefixes\"] !== undefined) {\r\n        contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(__getArrayIfSingleItem(data[\"CommonPrefixes\"]), context);\r\n    }\r\n    if (data.DeleteMarker === \"\") {\r\n        contents.DeleteMarkers = [];\r\n    }\r\n    if (data[\"DeleteMarker\"] !== undefined) {\r\n        contents.DeleteMarkers = deserializeAws_restXmlDeleteMarkers(__getArrayIfSingleItem(data[\"DeleteMarker\"]), context);\r\n    }\r\n    if (data[\"Delimiter\"] !== undefined) {\r\n        contents.Delimiter = data[\"Delimiter\"];\r\n    }\r\n    if (data[\"EncodingType\"] !== undefined) {\r\n        contents.EncodingType = data[\"EncodingType\"];\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"KeyMarker\"] !== undefined) {\r\n        contents.KeyMarker = data[\"KeyMarker\"];\r\n    }\r\n    if (data[\"MaxKeys\"] !== undefined) {\r\n        contents.MaxKeys = parseInt(data[\"MaxKeys\"]);\r\n    }\r\n    if (data[\"Name\"] !== undefined) {\r\n        contents.Name = data[\"Name\"];\r\n    }\r\n    if (data[\"NextKeyMarker\"] !== undefined) {\r\n        contents.NextKeyMarker = data[\"NextKeyMarker\"];\r\n    }\r\n    if (data[\"NextVersionIdMarker\"] !== undefined) {\r\n        contents.NextVersionIdMarker = data[\"NextVersionIdMarker\"];\r\n    }\r\n    if (data[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = data[\"Prefix\"];\r\n    }\r\n    if (data[\"VersionIdMarker\"] !== undefined) {\r\n        contents.VersionIdMarker = data[\"VersionIdMarker\"];\r\n    }\r\n    if (data.Version === \"\") {\r\n        contents.Versions = [];\r\n    }\r\n    if (data[\"Version\"] !== undefined) {\r\n        contents.Versions = deserializeAws_restXmlObjectVersionList(__getArrayIfSingleItem(data[\"Version\"]), context);\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListObjectVersionsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlListPartsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlListPartsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"ListPartsOutput\",\r\n        AbortDate: undefined,\r\n        AbortRuleId: undefined,\r\n        Bucket: undefined,\r\n        Initiator: undefined,\r\n        IsTruncated: undefined,\r\n        Key: undefined,\r\n        MaxParts: undefined,\r\n        NextPartNumberMarker: undefined,\r\n        Owner: undefined,\r\n        PartNumberMarker: undefined,\r\n        Parts: undefined,\r\n        RequestCharged: undefined,\r\n        StorageClass: undefined,\r\n        UploadId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-abort-rule-id\"] !== undefined) {\r\n        contents.AbortRuleId = output.headers[\"x-amz-abort-rule-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-abort-date\"] !== undefined) {\r\n        contents.AbortDate = new Date(output.headers[\"x-amz-abort-date\"]);\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    if (data[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = data[\"Bucket\"];\r\n    }\r\n    if (data[\"Initiator\"] !== undefined) {\r\n        contents.Initiator = deserializeAws_restXmlInitiator(data[\"Initiator\"], context);\r\n    }\r\n    if (data[\"IsTruncated\"] !== undefined) {\r\n        contents.IsTruncated = data[\"IsTruncated\"] == \"true\";\r\n    }\r\n    if (data[\"Key\"] !== undefined) {\r\n        contents.Key = data[\"Key\"];\r\n    }\r\n    if (data[\"MaxParts\"] !== undefined) {\r\n        contents.MaxParts = parseInt(data[\"MaxParts\"]);\r\n    }\r\n    if (data[\"NextPartNumberMarker\"] !== undefined) {\r\n        contents.NextPartNumberMarker = parseInt(data[\"NextPartNumberMarker\"]);\r\n    }\r\n    if (data[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(data[\"Owner\"], context);\r\n    }\r\n    if (data[\"PartNumberMarker\"] !== undefined) {\r\n        contents.PartNumberMarker = parseInt(data[\"PartNumberMarker\"]);\r\n    }\r\n    if (data.Part === \"\") {\r\n        contents.Parts = [];\r\n    }\r\n    if (data[\"Part\"] !== undefined) {\r\n        contents.Parts = deserializeAws_restXmlParts(__getArrayIfSingleItem(data[\"Part\"]), context);\r\n    }\r\n    if (data[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = data[\"StorageClass\"];\r\n    }\r\n    if (data[\"UploadId\"] !== undefined) {\r\n        contents.UploadId = data[\"UploadId\"];\r\n    }\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlListPartsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketAccelerateConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketAccelerateConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketAccelerateConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketAclCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketAclCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketAclCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketAnalyticsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketAnalyticsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketAnalyticsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketCorsCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketCorsCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketCorsCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketEncryptionCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketEncryptionCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketEncryptionCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketInventoryConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketInventoryConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketInventoryConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketLifecycleConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketLifecycleConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketLifecycleConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketLoggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketLoggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketLoggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketMetricsConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketMetricsConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketMetricsConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketNotificationConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketNotificationConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketNotificationConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketPolicyCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketPolicyCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketPolicyCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketReplicationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketReplicationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketReplicationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketRequestPaymentCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketRequestPaymentCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketRequestPaymentCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketVersioningCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketVersioningCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketVersioningCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutBucketWebsiteCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutBucketWebsiteCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutBucketWebsiteCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectOutput\",\r\n        ETag: undefined,\r\n        Expiration: undefined,\r\n        RequestCharged: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSEncryptionContext: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-context\"] !== undefined) {\r\n        contents.SSEKMSEncryptionContext = output.headers[\"x-amz-server-side-encryption-context\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"etag\"] !== undefined) {\r\n        contents.ETag = output.headers[\"etag\"];\r\n    }\r\n    if (output.headers[\"x-amz-expiration\"] !== undefined) {\r\n        contents.Expiration = output.headers[\"x-amz-expiration\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectAclCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectAclCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectAclOutput\",\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectAclCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"NoSuchKey\":\r\n        case \"com.amazonaws.s3#NoSuchKey\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlNoSuchKeyResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectLegalHoldCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectLegalHoldCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectLegalHoldOutput\",\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectLegalHoldCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectLockConfigurationCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectLockConfigurationCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectLockConfigurationOutput\",\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectLockConfigurationCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectRetentionCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectRetentionCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectRetentionOutput\",\r\n        RequestCharged: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectRetentionCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutObjectTaggingCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutObjectTaggingCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"PutObjectTaggingOutput\",\r\n        VersionId: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-version-id\"] !== undefined) {\r\n        contents.VersionId = output.headers[\"x-amz-version-id\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutObjectTaggingCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlPutPublicAccessBlockCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlPutPublicAccessBlockCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n    };\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlPutPublicAccessBlockCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlRestoreObjectCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlRestoreObjectCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"RestoreObjectOutput\",\r\n        RequestCharged: undefined,\r\n        RestoreOutputPath: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-restore-output-path\"] !== undefined) {\r\n        contents.RestoreOutputPath = output.headers[\"x-amz-restore-output-path\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlRestoreObjectCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        case \"ObjectAlreadyInActiveTierError\":\r\n        case \"com.amazonaws.s3#ObjectAlreadyInActiveTierError\":\r\n            response = {\r\n                ...(await deserializeAws_restXmlObjectAlreadyInActiveTierErrorResponse(parsedOutput, context)),\r\n                name: errorCode,\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n            break;\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlSelectObjectContentCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlSelectObjectContentCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"SelectObjectContentOutput\",\r\n        Payload: undefined,\r\n    };\r\n    const data = context.eventStreamMarshaller.deserialize(output.body, async (event) => {\r\n        const eventName = Object.keys(event)[0];\r\n        const eventHeaders = Object.entries(event[eventName].headers).reduce((accummulator, curr) => {\r\n            accummulator[curr[0]] = curr[1].value;\r\n            return accummulator;\r\n        }, {});\r\n        const eventMessage = {\r\n            headers: eventHeaders,\r\n            body: event[eventName].body,\r\n        };\r\n        const parsedEvent = {\r\n            [eventName]: eventMessage,\r\n        };\r\n        return await deserializeAws_restXmlSelectObjectContentEventStream_event(parsedEvent, context);\r\n    });\r\n    contents.Payload = data;\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlSelectObjectContentCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlUploadPartCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlUploadPartCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"UploadPartOutput\",\r\n        ETag: undefined,\r\n        RequestCharged: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"etag\"] !== undefined) {\r\n        contents.ETag = output.headers[\"etag\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    await collectBody(output.body, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlUploadPartCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nexport const deserializeAws_restXmlUploadPartCopyCommand = async (output, context) => {\r\n    if (output.statusCode !== 200 && output.statusCode >= 400) {\r\n        return deserializeAws_restXmlUploadPartCopyCommandError(output, context);\r\n    }\r\n    const contents = {\r\n        $metadata: deserializeMetadata(output),\r\n        __type: \"UploadPartCopyOutput\",\r\n        CopyPartResult: undefined,\r\n        CopySourceVersionId: undefined,\r\n        RequestCharged: undefined,\r\n        SSECustomerAlgorithm: undefined,\r\n        SSECustomerKeyMD5: undefined,\r\n        SSEKMSKeyId: undefined,\r\n        ServerSideEncryption: undefined,\r\n    };\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-key-md5\"] !== undefined) {\r\n        contents.SSECustomerKeyMD5 = output.headers[\"x-amz-server-side-encryption-customer-key-md5\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption\"] !== undefined) {\r\n        contents.ServerSideEncryption = output.headers[\"x-amz-server-side-encryption\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"] !== undefined) {\r\n        contents.SSEKMSKeyId = output.headers[\"x-amz-server-side-encryption-aws-kms-key-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-request-charged\"] !== undefined) {\r\n        contents.RequestCharged = output.headers[\"x-amz-request-charged\"];\r\n    }\r\n    if (output.headers[\"x-amz-copy-source-version-id\"] !== undefined) {\r\n        contents.CopySourceVersionId = output.headers[\"x-amz-copy-source-version-id\"];\r\n    }\r\n    if (output.headers[\"x-amz-server-side-encryption-customer-algorithm\"] !== undefined) {\r\n        contents.SSECustomerAlgorithm = output.headers[\"x-amz-server-side-encryption-customer-algorithm\"];\r\n    }\r\n    const data = await parseBody(output.body, context);\r\n    contents.CopyPartResult = deserializeAws_restXmlCopyPartResult(data, context);\r\n    return Promise.resolve(contents);\r\n};\r\nconst deserializeAws_restXmlUploadPartCopyCommandError = async (output, context) => {\r\n    const parsedOutput = {\r\n        ...output,\r\n        body: await parseBody(output.body, context),\r\n    };\r\n    let response;\r\n    let errorCode = \"UnknownError\";\r\n    errorCode = loadRestXmlErrorCode(output, parsedOutput.body);\r\n    switch (errorCode) {\r\n        default:\r\n            const parsedBody = parsedOutput.body;\r\n            errorCode = parsedBody.code || parsedBody.Code || errorCode;\r\n            response = {\r\n                ...parsedBody,\r\n                name: `${errorCode}`,\r\n                message: parsedBody.message || parsedBody.Message || errorCode,\r\n                $fault: \"client\",\r\n                $metadata: deserializeMetadata(output),\r\n            };\r\n    }\r\n    const message = response.message || response.Message || errorCode;\r\n    response.message = message;\r\n    delete response.Message;\r\n    return Promise.reject(Object.assign(new Error(message), response));\r\n};\r\nconst deserializeAws_restXmlSelectObjectContentEventStream_event = async (output, context) => {\r\n    if (output[\"Stats\"] !== undefined) {\r\n        return {\r\n            Stats: await deserializeAws_restXmlStatsEvent_event(output[\"Stats\"], context),\r\n        };\r\n    }\r\n    if (output[\"End\"] !== undefined) {\r\n        return {\r\n            End: await deserializeAws_restXmlEndEvent_event(output[\"End\"], context),\r\n        };\r\n    }\r\n    if (output[\"Progress\"] !== undefined) {\r\n        return {\r\n            Progress: await deserializeAws_restXmlProgressEvent_event(output[\"Progress\"], context),\r\n        };\r\n    }\r\n    if (output[\"Records\"] !== undefined) {\r\n        return {\r\n            Records: await deserializeAws_restXmlRecordsEvent_event(output[\"Records\"], context),\r\n        };\r\n    }\r\n    if (output[\"Cont\"] !== undefined) {\r\n        return {\r\n            Cont: await deserializeAws_restXmlContinuationEvent_event(output[\"Cont\"], context),\r\n        };\r\n    }\r\n    return { $unknown: output };\r\n};\r\nconst deserializeAws_restXmlContinuationEvent_event = async (output, context) => {\r\n    let contents = {};\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlEndEvent_event = async (output, context) => {\r\n    let contents = {};\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlProgressEvent_event = async (output, context) => {\r\n    let contents = {\r\n        __type: \"ProgressEvent\",\r\n    };\r\n    contents.Details = await parseBody(output.body, context);\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlRecordsEvent_event = async (output, context) => {\r\n    let contents = {\r\n        __type: \"RecordsEvent\",\r\n    };\r\n    contents.Payload = output.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlStatsEvent_event = async (output, context) => {\r\n    let contents = {\r\n        __type: \"StatsEvent\",\r\n    };\r\n    contents.Details = await parseBody(output.body, context);\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlBucketAlreadyExistsResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"BucketAlreadyExists\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlBucketAlreadyOwnedByYouResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"BucketAlreadyOwnedByYou\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlNoSuchBucketResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"NoSuchBucket\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlNoSuchKeyResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"NoSuchKey\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlNoSuchUploadResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"NoSuchUpload\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectAlreadyInActiveTierErrorResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"ObjectAlreadyInActiveTierError\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectNotInActiveTierErrorResponse = async (parsedOutput, context) => {\r\n    const contents = {\r\n        name: \"ObjectNotInActiveTierError\",\r\n        $fault: \"client\",\r\n        $metadata: deserializeMetadata(parsedOutput),\r\n    };\r\n    const data = parsedOutput.body;\r\n    return contents;\r\n};\r\nconst serializeAws_restXmlAbortIncompleteMultipartUpload = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AbortIncompleteMultipartUpload\");\r\n    if (input.DaysAfterInitiation !== undefined) {\r\n        const node = new __XmlNode(\"DaysAfterInitiation\")\r\n            .addChildNode(new __XmlText(String(input.DaysAfterInitiation)))\r\n            .withName(\"DaysAfterInitiation\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAccelerateConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AccelerateConfiguration\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"BucketAccelerateStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAccessControlPolicy = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AccessControlPolicy\");\r\n    if (input.Grants !== undefined) {\r\n        const nodes = serializeAws_restXmlGrants(input.Grants, context);\r\n        const containerNode = new __XmlNode(\"AccessControlList\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    if (input.Owner !== undefined) {\r\n        const node = serializeAws_restXmlOwner(input.Owner, context).withName(\"Owner\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAccessControlTranslation = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AccessControlTranslation\");\r\n    if (input.Owner !== undefined) {\r\n        const node = new __XmlNode(\"OwnerOverride\").addChildNode(new __XmlText(input.Owner)).withName(\"Owner\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAllowedHeaders = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"AllowedHeader\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlAllowedMethods = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"AllowedMethod\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlAllowedOrigins = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"AllowedOrigin\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlAnalyticsAndOperator = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AnalyticsAndOperator\");\r\n    if (input.Tags !== undefined) {\r\n        const nodes = serializeAws_restXmlTagSet(input.Tags, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Tag\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAnalyticsConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AnalyticsConfiguration\");\r\n    if (input.StorageClassAnalysis !== undefined) {\r\n        const node = serializeAws_restXmlStorageClassAnalysis(input.StorageClassAnalysis, context).withName(\"StorageClassAnalysis\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlAnalyticsFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"AnalyticsId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAnalyticsExportDestination = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AnalyticsExportDestination\");\r\n    if (input.S3BucketDestination !== undefined) {\r\n        const node = serializeAws_restXmlAnalyticsS3BucketDestination(input.S3BucketDestination, context).withName(\"S3BucketDestination\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAnalyticsFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AnalyticsFilter\");\r\n    if (input.And !== undefined) {\r\n        const node = serializeAws_restXmlAnalyticsAndOperator(input.And, context).withName(\"And\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tag !== undefined) {\r\n        const node = serializeAws_restXmlTag(input.Tag, context).withName(\"Tag\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlAnalyticsS3BucketDestination = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"AnalyticsS3BucketDestination\");\r\n    if (input.Format !== undefined) {\r\n        const node = new __XmlNode(\"AnalyticsS3ExportFileFormat\")\r\n            .addChildNode(new __XmlText(input.Format))\r\n            .withName(\"Format\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const node = new __XmlNode(\"BucketName\").addChildNode(new __XmlText(input.Bucket)).withName(\"Bucket\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.BucketAccountId !== undefined) {\r\n        const node = new __XmlNode(\"AccountId\")\r\n            .addChildNode(new __XmlText(input.BucketAccountId))\r\n            .withName(\"BucketAccountId\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlBucketLifecycleConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"BucketLifecycleConfiguration\");\r\n    if (input.Rules !== undefined) {\r\n        const nodes = serializeAws_restXmlLifecycleRules(input.Rules, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Rule\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlBucketLoggingStatus = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"BucketLoggingStatus\");\r\n    if (input.LoggingEnabled !== undefined) {\r\n        const node = serializeAws_restXmlLoggingEnabled(input.LoggingEnabled, context).withName(\"LoggingEnabled\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCompletedMultipartUpload = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CompletedMultipartUpload\");\r\n    if (input.Parts !== undefined) {\r\n        const nodes = serializeAws_restXmlCompletedPartList(input.Parts, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Part\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCompletedPart = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CompletedPart\");\r\n    if (input.ETag !== undefined) {\r\n        const node = new __XmlNode(\"ETag\").addChildNode(new __XmlText(input.ETag)).withName(\"ETag\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.PartNumber !== undefined) {\r\n        const node = new __XmlNode(\"PartNumber\")\r\n            .addChildNode(new __XmlText(String(input.PartNumber)))\r\n            .withName(\"PartNumber\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCompletedPartList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlCompletedPart(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlCondition = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Condition\");\r\n    if (input.KeyPrefixEquals !== undefined) {\r\n        const node = new __XmlNode(\"KeyPrefixEquals\")\r\n            .addChildNode(new __XmlText(input.KeyPrefixEquals))\r\n            .withName(\"KeyPrefixEquals\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.HttpErrorCodeReturnedEquals !== undefined) {\r\n        const node = new __XmlNode(\"HttpErrorCodeReturnedEquals\")\r\n            .addChildNode(new __XmlText(input.HttpErrorCodeReturnedEquals))\r\n            .withName(\"HttpErrorCodeReturnedEquals\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCORSConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CORSConfiguration\");\r\n    if (input.CORSRules !== undefined) {\r\n        const nodes = serializeAws_restXmlCORSRules(input.CORSRules, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"CORSRule\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCORSRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CORSRule\");\r\n    if (input.MaxAgeSeconds !== undefined) {\r\n        const node = new __XmlNode(\"MaxAgeSeconds\")\r\n            .addChildNode(new __XmlText(String(input.MaxAgeSeconds)))\r\n            .withName(\"MaxAgeSeconds\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AllowedOrigins !== undefined) {\r\n        const nodes = serializeAws_restXmlAllowedOrigins(input.AllowedOrigins, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"AllowedOrigin\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.AllowedHeaders !== undefined) {\r\n        const nodes = serializeAws_restXmlAllowedHeaders(input.AllowedHeaders, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"AllowedHeader\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.AllowedMethods !== undefined) {\r\n        const nodes = serializeAws_restXmlAllowedMethods(input.AllowedMethods, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"AllowedMethod\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.ExposeHeaders !== undefined) {\r\n        const nodes = serializeAws_restXmlExposeHeaders(input.ExposeHeaders, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"ExposeHeader\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCORSRules = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlCORSRule(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlCreateBucketConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CreateBucketConfiguration\");\r\n    if (input.LocationConstraint !== undefined) {\r\n        const node = new __XmlNode(\"BucketLocationConstraint\")\r\n            .addChildNode(new __XmlText(input.LocationConstraint))\r\n            .withName(\"LocationConstraint\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCSVInput = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CSVInput\");\r\n    if (input.FileHeaderInfo !== undefined) {\r\n        const node = new __XmlNode(\"FileHeaderInfo\")\r\n            .addChildNode(new __XmlText(input.FileHeaderInfo))\r\n            .withName(\"FileHeaderInfo\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Comments !== undefined) {\r\n        const node = new __XmlNode(\"Comments\").addChildNode(new __XmlText(input.Comments)).withName(\"Comments\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AllowQuotedRecordDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"AllowQuotedRecordDelimiter\")\r\n            .addChildNode(new __XmlText(String(input.AllowQuotedRecordDelimiter)))\r\n            .withName(\"AllowQuotedRecordDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.FieldDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"FieldDelimiter\")\r\n            .addChildNode(new __XmlText(input.FieldDelimiter))\r\n            .withName(\"FieldDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.QuoteCharacter !== undefined) {\r\n        const node = new __XmlNode(\"QuoteCharacter\")\r\n            .addChildNode(new __XmlText(input.QuoteCharacter))\r\n            .withName(\"QuoteCharacter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.QuoteEscapeCharacter !== undefined) {\r\n        const node = new __XmlNode(\"QuoteEscapeCharacter\")\r\n            .addChildNode(new __XmlText(input.QuoteEscapeCharacter))\r\n            .withName(\"QuoteEscapeCharacter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.RecordDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"RecordDelimiter\")\r\n            .addChildNode(new __XmlText(input.RecordDelimiter))\r\n            .withName(\"RecordDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlCSVOutput = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"CSVOutput\");\r\n    if (input.QuoteEscapeCharacter !== undefined) {\r\n        const node = new __XmlNode(\"QuoteEscapeCharacter\")\r\n            .addChildNode(new __XmlText(input.QuoteEscapeCharacter))\r\n            .withName(\"QuoteEscapeCharacter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.QuoteCharacter !== undefined) {\r\n        const node = new __XmlNode(\"QuoteCharacter\")\r\n            .addChildNode(new __XmlText(input.QuoteCharacter))\r\n            .withName(\"QuoteCharacter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.RecordDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"RecordDelimiter\")\r\n            .addChildNode(new __XmlText(input.RecordDelimiter))\r\n            .withName(\"RecordDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.QuoteFields !== undefined) {\r\n        const node = new __XmlNode(\"QuoteFields\").addChildNode(new __XmlText(input.QuoteFields)).withName(\"QuoteFields\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.FieldDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"FieldDelimiter\")\r\n            .addChildNode(new __XmlText(input.FieldDelimiter))\r\n            .withName(\"FieldDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlDefaultRetention = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"DefaultRetention\");\r\n    if (input.Mode !== undefined) {\r\n        const node = new __XmlNode(\"ObjectLockRetentionMode\").addChildNode(new __XmlText(input.Mode)).withName(\"Mode\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Days !== undefined) {\r\n        const node = new __XmlNode(\"Days\").addChildNode(new __XmlText(String(input.Days))).withName(\"Days\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Years !== undefined) {\r\n        const node = new __XmlNode(\"Years\").addChildNode(new __XmlText(String(input.Years))).withName(\"Years\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlDelete = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Delete\");\r\n    if (input.Objects !== undefined) {\r\n        const nodes = serializeAws_restXmlObjectIdentifierList(input.Objects, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Object\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Quiet !== undefined) {\r\n        const node = new __XmlNode(\"Quiet\").addChildNode(new __XmlText(String(input.Quiet))).withName(\"Quiet\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlDeleteMarkerReplication = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"DeleteMarkerReplication\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"DeleteMarkerReplicationStatus\")\r\n            .addChildNode(new __XmlText(input.Status))\r\n            .withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlDestination = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Destination\");\r\n    if (input.StorageClass !== undefined) {\r\n        const node = new __XmlNode(\"StorageClass\").addChildNode(new __XmlText(input.StorageClass)).withName(\"StorageClass\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Metrics !== undefined) {\r\n        const node = serializeAws_restXmlMetrics(input.Metrics, context).withName(\"Metrics\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ReplicationTime !== undefined) {\r\n        const node = serializeAws_restXmlReplicationTime(input.ReplicationTime, context).withName(\"ReplicationTime\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Account !== undefined) {\r\n        const node = new __XmlNode(\"AccountId\").addChildNode(new __XmlText(input.Account)).withName(\"Account\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.EncryptionConfiguration !== undefined) {\r\n        const node = serializeAws_restXmlEncryptionConfiguration(input.EncryptionConfiguration, context).withName(\"EncryptionConfiguration\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Bucket !== undefined) {\r\n        const node = new __XmlNode(\"BucketName\").addChildNode(new __XmlText(input.Bucket)).withName(\"Bucket\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AccessControlTranslation !== undefined) {\r\n        const node = serializeAws_restXmlAccessControlTranslation(input.AccessControlTranslation, context).withName(\"AccessControlTranslation\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlEncryption = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Encryption\");\r\n    if (input.KMSContext !== undefined) {\r\n        const node = new __XmlNode(\"KMSContext\").addChildNode(new __XmlText(input.KMSContext)).withName(\"KMSContext\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.KMSKeyId !== undefined) {\r\n        const node = new __XmlNode(\"SSEKMSKeyId\").addChildNode(new __XmlText(input.KMSKeyId)).withName(\"KMSKeyId\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.EncryptionType !== undefined) {\r\n        const node = new __XmlNode(\"ServerSideEncryption\")\r\n            .addChildNode(new __XmlText(input.EncryptionType))\r\n            .withName(\"EncryptionType\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlEncryptionConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"EncryptionConfiguration\");\r\n    if (input.ReplicaKmsKeyID !== undefined) {\r\n        const node = new __XmlNode(\"ReplicaKmsKeyID\")\r\n            .addChildNode(new __XmlText(input.ReplicaKmsKeyID))\r\n            .withName(\"ReplicaKmsKeyID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlErrorDocument = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ErrorDocument\");\r\n    if (input.Key !== undefined) {\r\n        const node = new __XmlNode(\"ObjectKey\").addChildNode(new __XmlText(input.Key)).withName(\"Key\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlEventList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"Event\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlExistingObjectReplication = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ExistingObjectReplication\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"ExistingObjectReplicationStatus\")\r\n            .addChildNode(new __XmlText(input.Status))\r\n            .withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlExposeHeaders = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"ExposeHeader\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlFilterRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"FilterRule\");\r\n    if (input.Name !== undefined) {\r\n        const node = new __XmlNode(\"FilterRuleName\").addChildNode(new __XmlText(input.Name)).withName(\"Name\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Value !== undefined) {\r\n        const node = new __XmlNode(\"FilterRuleValue\").addChildNode(new __XmlText(input.Value)).withName(\"Value\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlFilterRuleList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlFilterRule(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlGlacierJobParameters = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"GlacierJobParameters\");\r\n    if (input.Tier !== undefined) {\r\n        const node = new __XmlNode(\"Tier\").addChildNode(new __XmlText(input.Tier)).withName(\"Tier\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlGrant = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Grant\");\r\n    if (input.Permission !== undefined) {\r\n        const node = new __XmlNode(\"Permission\").addChildNode(new __XmlText(input.Permission)).withName(\"Permission\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Grantee !== undefined) {\r\n        const node = serializeAws_restXmlGrantee(input.Grantee, context).withName(\"Grantee\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlGrantee = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Grantee\");\r\n    if (input.ID !== undefined) {\r\n        const node = new __XmlNode(\"ID\").addChildNode(new __XmlText(input.ID)).withName(\"ID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.DisplayName !== undefined) {\r\n        const node = new __XmlNode(\"DisplayName\").addChildNode(new __XmlText(input.DisplayName)).withName(\"DisplayName\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.EmailAddress !== undefined) {\r\n        const node = new __XmlNode(\"EmailAddress\").addChildNode(new __XmlText(input.EmailAddress)).withName(\"EmailAddress\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.URI !== undefined) {\r\n        const node = new __XmlNode(\"URI\").addChildNode(new __XmlText(input.URI)).withName(\"URI\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Type !== undefined) {\r\n        bodyNode.addAttribute(\"xsi:type\", input.Type);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlGrants = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlGrant(entry, context);\r\n        return node.withName(\"Grant\");\r\n    });\r\n};\r\nconst serializeAws_restXmlIndexDocument = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"IndexDocument\");\r\n    if (input.Suffix !== undefined) {\r\n        const node = new __XmlNode(\"Suffix\").addChildNode(new __XmlText(input.Suffix)).withName(\"Suffix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInputSerialization = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InputSerialization\");\r\n    if (input.CompressionType !== undefined) {\r\n        const node = new __XmlNode(\"CompressionType\")\r\n            .addChildNode(new __XmlText(input.CompressionType))\r\n            .withName(\"CompressionType\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Parquet !== undefined) {\r\n        const node = serializeAws_restXmlParquetInput(input.Parquet, context).withName(\"Parquet\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.CSV !== undefined) {\r\n        const node = serializeAws_restXmlCSVInput(input.CSV, context).withName(\"CSV\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.JSON !== undefined) {\r\n        const node = serializeAws_restXmlJSONInput(input.JSON, context).withName(\"JSON\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventoryConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventoryConfiguration\");\r\n    if (input.OptionalFields !== undefined) {\r\n        const nodes = serializeAws_restXmlInventoryOptionalFields(input.OptionalFields, context);\r\n        const containerNode = new __XmlNode(\"OptionalFields\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    if (input.Destination !== undefined) {\r\n        const node = serializeAws_restXmlInventoryDestination(input.Destination, context).withName(\"Destination\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"InventoryId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlInventoryFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Schedule !== undefined) {\r\n        const node = serializeAws_restXmlInventorySchedule(input.Schedule, context).withName(\"Schedule\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.IsEnabled !== undefined) {\r\n        const node = new __XmlNode(\"IsEnabled\").addChildNode(new __XmlText(String(input.IsEnabled))).withName(\"IsEnabled\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.IncludedObjectVersions !== undefined) {\r\n        const node = new __XmlNode(\"InventoryIncludedObjectVersions\")\r\n            .addChildNode(new __XmlText(input.IncludedObjectVersions))\r\n            .withName(\"IncludedObjectVersions\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventoryDestination = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventoryDestination\");\r\n    if (input.S3BucketDestination !== undefined) {\r\n        const node = serializeAws_restXmlInventoryS3BucketDestination(input.S3BucketDestination, context).withName(\"S3BucketDestination\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventoryEncryption = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventoryEncryption\");\r\n    if (input.SSES3 !== undefined) {\r\n        const node = serializeAws_restXmlSSES3(input.SSES3, context).withName(\"SSE-S3\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.SSEKMS !== undefined) {\r\n        const node = serializeAws_restXmlSSEKMS(input.SSEKMS, context).withName(\"SSE-KMS\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventoryFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventoryFilter\");\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventoryOptionalFields = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = new __XmlNode(\"InventoryOptionalField\").addChildNode(new __XmlText(entry));\r\n        return node.withName(\"Field\");\r\n    });\r\n};\r\nconst serializeAws_restXmlInventoryS3BucketDestination = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventoryS3BucketDestination\");\r\n    if (input.Bucket !== undefined) {\r\n        const node = new __XmlNode(\"BucketName\").addChildNode(new __XmlText(input.Bucket)).withName(\"Bucket\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AccountId !== undefined) {\r\n        const node = new __XmlNode(\"AccountId\").addChildNode(new __XmlText(input.AccountId)).withName(\"AccountId\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Encryption !== undefined) {\r\n        const node = serializeAws_restXmlInventoryEncryption(input.Encryption, context).withName(\"Encryption\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Format !== undefined) {\r\n        const node = new __XmlNode(\"InventoryFormat\").addChildNode(new __XmlText(input.Format)).withName(\"Format\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlInventorySchedule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"InventorySchedule\");\r\n    if (input.Frequency !== undefined) {\r\n        const node = new __XmlNode(\"InventoryFrequency\").addChildNode(new __XmlText(input.Frequency)).withName(\"Frequency\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlJSONInput = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"JSONInput\");\r\n    if (input.Type !== undefined) {\r\n        const node = new __XmlNode(\"JSONType\").addChildNode(new __XmlText(input.Type)).withName(\"Type\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlJSONOutput = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"JSONOutput\");\r\n    if (input.RecordDelimiter !== undefined) {\r\n        const node = new __XmlNode(\"RecordDelimiter\")\r\n            .addChildNode(new __XmlText(input.RecordDelimiter))\r\n            .withName(\"RecordDelimiter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLambdaFunctionConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LambdaFunctionConfiguration\");\r\n    if (input.LambdaFunctionArn !== undefined) {\r\n        const node = new __XmlNode(\"LambdaFunctionArn\")\r\n            .addChildNode(new __XmlText(input.LambdaFunctionArn))\r\n            .withName(\"CloudFunction\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"NotificationId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Events !== undefined) {\r\n        const nodes = serializeAws_restXmlEventList(input.Events, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Event\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlNotificationConfigurationFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLambdaFunctionConfigurationList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlLambdaFunctionConfiguration(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlLifecycleExpiration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LifecycleExpiration\");\r\n    if (input.Date !== undefined) {\r\n        const node = new __XmlNode(\"Date\")\r\n            .addChildNode(new __XmlText(input.Date.toISOString().split(\".\")[0] + \"Z\"))\r\n            .withName(\"Date\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ExpiredObjectDeleteMarker !== undefined) {\r\n        const node = new __XmlNode(\"ExpiredObjectDeleteMarker\")\r\n            .addChildNode(new __XmlText(String(input.ExpiredObjectDeleteMarker)))\r\n            .withName(\"ExpiredObjectDeleteMarker\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Days !== undefined) {\r\n        const node = new __XmlNode(\"Days\").addChildNode(new __XmlText(String(input.Days))).withName(\"Days\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLifecycleRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LifecycleRule\");\r\n    if (input.ID !== undefined) {\r\n        const node = new __XmlNode(\"ID\").addChildNode(new __XmlText(input.ID)).withName(\"ID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"ExpirationStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AbortIncompleteMultipartUpload !== undefined) {\r\n        const node = serializeAws_restXmlAbortIncompleteMultipartUpload(input.AbortIncompleteMultipartUpload, context).withName(\"AbortIncompleteMultipartUpload\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.NoncurrentVersionTransitions !== undefined) {\r\n        const nodes = serializeAws_restXmlNoncurrentVersionTransitionList(input.NoncurrentVersionTransitions, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"NoncurrentVersionTransition\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Transitions !== undefined) {\r\n        const nodes = serializeAws_restXmlTransitionList(input.Transitions, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Transition\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlLifecycleRuleFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Expiration !== undefined) {\r\n        const node = serializeAws_restXmlLifecycleExpiration(input.Expiration, context).withName(\"Expiration\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.NoncurrentVersionExpiration !== undefined) {\r\n        const node = serializeAws_restXmlNoncurrentVersionExpiration(input.NoncurrentVersionExpiration, context).withName(\"NoncurrentVersionExpiration\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLifecycleRuleAndOperator = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LifecycleRuleAndOperator\");\r\n    if (input.Tags !== undefined) {\r\n        const nodes = serializeAws_restXmlTagSet(input.Tags, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Tag\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLifecycleRuleFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LifecycleRuleFilter\");\r\n    if (input.And !== undefined) {\r\n        const node = serializeAws_restXmlLifecycleRuleAndOperator(input.And, context).withName(\"And\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tag !== undefined) {\r\n        const node = serializeAws_restXmlTag(input.Tag, context).withName(\"Tag\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlLifecycleRules = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlLifecycleRule(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlLoggingEnabled = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"LoggingEnabled\");\r\n    if (input.TargetBucket !== undefined) {\r\n        const node = new __XmlNode(\"TargetBucket\").addChildNode(new __XmlText(input.TargetBucket)).withName(\"TargetBucket\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.TargetPrefix !== undefined) {\r\n        const node = new __XmlNode(\"TargetPrefix\").addChildNode(new __XmlText(input.TargetPrefix)).withName(\"TargetPrefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.TargetGrants !== undefined) {\r\n        const nodes = serializeAws_restXmlTargetGrants(input.TargetGrants, context);\r\n        const containerNode = new __XmlNode(\"TargetGrants\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlMetadataEntry = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"MetadataEntry\");\r\n    if (input.Name !== undefined) {\r\n        const node = new __XmlNode(\"MetadataKey\").addChildNode(new __XmlText(input.Name)).withName(\"Name\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Value !== undefined) {\r\n        const node = new __XmlNode(\"MetadataValue\").addChildNode(new __XmlText(input.Value)).withName(\"Value\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlMetrics = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Metrics\");\r\n    if (input.EventThreshold !== undefined) {\r\n        const node = serializeAws_restXmlReplicationTimeValue(input.EventThreshold, context).withName(\"EventThreshold\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"MetricsStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlMetricsAndOperator = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"MetricsAndOperator\");\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tags !== undefined) {\r\n        const nodes = serializeAws_restXmlTagSet(input.Tags, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Tag\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlMetricsConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"MetricsConfiguration\");\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlMetricsFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"MetricsId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlMetricsFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"MetricsFilter\");\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.And !== undefined) {\r\n        const node = serializeAws_restXmlMetricsAndOperator(input.And, context).withName(\"And\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tag !== undefined) {\r\n        const node = serializeAws_restXmlTag(input.Tag, context).withName(\"Tag\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlNoncurrentVersionExpiration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"NoncurrentVersionExpiration\");\r\n    if (input.NoncurrentDays !== undefined) {\r\n        const node = new __XmlNode(\"Days\")\r\n            .addChildNode(new __XmlText(String(input.NoncurrentDays)))\r\n            .withName(\"NoncurrentDays\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlNoncurrentVersionTransition = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"NoncurrentVersionTransition\");\r\n    if (input.NoncurrentDays !== undefined) {\r\n        const node = new __XmlNode(\"Days\")\r\n            .addChildNode(new __XmlText(String(input.NoncurrentDays)))\r\n            .withName(\"NoncurrentDays\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.StorageClass !== undefined) {\r\n        const node = new __XmlNode(\"TransitionStorageClass\")\r\n            .addChildNode(new __XmlText(input.StorageClass))\r\n            .withName(\"StorageClass\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlNoncurrentVersionTransitionList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlNoncurrentVersionTransition(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlNotificationConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"NotificationConfiguration\");\r\n    if (input.LambdaFunctionConfigurations !== undefined) {\r\n        const nodes = serializeAws_restXmlLambdaFunctionConfigurationList(input.LambdaFunctionConfigurations, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"CloudFunctionConfiguration\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.QueueConfigurations !== undefined) {\r\n        const nodes = serializeAws_restXmlQueueConfigurationList(input.QueueConfigurations, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"QueueConfiguration\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.TopicConfigurations !== undefined) {\r\n        const nodes = serializeAws_restXmlTopicConfigurationList(input.TopicConfigurations, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"TopicConfiguration\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlNotificationConfigurationFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"NotificationConfigurationFilter\");\r\n    if (input.Key !== undefined) {\r\n        const node = serializeAws_restXmlS3KeyFilter(input.Key, context).withName(\"S3Key\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlObjectIdentifier = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ObjectIdentifier\");\r\n    if (input.Key !== undefined) {\r\n        const node = new __XmlNode(\"ObjectKey\").addChildNode(new __XmlText(input.Key)).withName(\"Key\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.VersionId !== undefined) {\r\n        const node = new __XmlNode(\"ObjectVersionId\").addChildNode(new __XmlText(input.VersionId)).withName(\"VersionId\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlObjectIdentifierList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlObjectIdentifier(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlObjectLockConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ObjectLockConfiguration\");\r\n    if (input.ObjectLockEnabled !== undefined) {\r\n        const node = new __XmlNode(\"ObjectLockEnabled\")\r\n            .addChildNode(new __XmlText(input.ObjectLockEnabled))\r\n            .withName(\"ObjectLockEnabled\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Rule !== undefined) {\r\n        const node = serializeAws_restXmlObjectLockRule(input.Rule, context).withName(\"Rule\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlObjectLockLegalHold = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ObjectLockLegalHold\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"ObjectLockLegalHoldStatus\")\r\n            .addChildNode(new __XmlText(input.Status))\r\n            .withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlObjectLockRetention = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ObjectLockRetention\");\r\n    if (input.Mode !== undefined) {\r\n        const node = new __XmlNode(\"ObjectLockRetentionMode\").addChildNode(new __XmlText(input.Mode)).withName(\"Mode\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.RetainUntilDate !== undefined) {\r\n        const node = new __XmlNode(\"Date\")\r\n            .addChildNode(new __XmlText(input.RetainUntilDate.toISOString().split(\".\")[0] + \"Z\"))\r\n            .withName(\"RetainUntilDate\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlObjectLockRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ObjectLockRule\");\r\n    if (input.DefaultRetention !== undefined) {\r\n        const node = serializeAws_restXmlDefaultRetention(input.DefaultRetention, context).withName(\"DefaultRetention\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlOutputLocation = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"OutputLocation\");\r\n    if (input.S3 !== undefined) {\r\n        const node = serializeAws_restXmlS3Location(input.S3, context).withName(\"S3\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlOutputSerialization = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"OutputSerialization\");\r\n    if (input.CSV !== undefined) {\r\n        const node = serializeAws_restXmlCSVOutput(input.CSV, context).withName(\"CSV\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.JSON !== undefined) {\r\n        const node = serializeAws_restXmlJSONOutput(input.JSON, context).withName(\"JSON\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlOwner = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Owner\");\r\n    if (input.DisplayName !== undefined) {\r\n        const node = new __XmlNode(\"DisplayName\").addChildNode(new __XmlText(input.DisplayName)).withName(\"DisplayName\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ID !== undefined) {\r\n        const node = new __XmlNode(\"ID\").addChildNode(new __XmlText(input.ID)).withName(\"ID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlParquetInput = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ParquetInput\");\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlPublicAccessBlockConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"PublicAccessBlockConfiguration\");\r\n    if (input.RestrictPublicBuckets !== undefined) {\r\n        const node = new __XmlNode(\"Setting\")\r\n            .addChildNode(new __XmlText(String(input.RestrictPublicBuckets)))\r\n            .withName(\"RestrictPublicBuckets\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.BlockPublicAcls !== undefined) {\r\n        const node = new __XmlNode(\"Setting\")\r\n            .addChildNode(new __XmlText(String(input.BlockPublicAcls)))\r\n            .withName(\"BlockPublicAcls\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.IgnorePublicAcls !== undefined) {\r\n        const node = new __XmlNode(\"Setting\")\r\n            .addChildNode(new __XmlText(String(input.IgnorePublicAcls)))\r\n            .withName(\"IgnorePublicAcls\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.BlockPublicPolicy !== undefined) {\r\n        const node = new __XmlNode(\"Setting\")\r\n            .addChildNode(new __XmlText(String(input.BlockPublicPolicy)))\r\n            .withName(\"BlockPublicPolicy\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlQueueConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"QueueConfiguration\");\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"NotificationId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Events !== undefined) {\r\n        const nodes = serializeAws_restXmlEventList(input.Events, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Event\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.QueueArn !== undefined) {\r\n        const node = new __XmlNode(\"QueueArn\").addChildNode(new __XmlText(input.QueueArn)).withName(\"Queue\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlNotificationConfigurationFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlQueueConfigurationList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlQueueConfiguration(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlRedirect = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Redirect\");\r\n    if (input.Protocol !== undefined) {\r\n        const node = new __XmlNode(\"Protocol\").addChildNode(new __XmlText(input.Protocol)).withName(\"Protocol\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ReplaceKeyWith !== undefined) {\r\n        const node = new __XmlNode(\"ReplaceKeyWith\")\r\n            .addChildNode(new __XmlText(input.ReplaceKeyWith))\r\n            .withName(\"ReplaceKeyWith\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ReplaceKeyPrefixWith !== undefined) {\r\n        const node = new __XmlNode(\"ReplaceKeyPrefixWith\")\r\n            .addChildNode(new __XmlText(input.ReplaceKeyPrefixWith))\r\n            .withName(\"ReplaceKeyPrefixWith\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.HostName !== undefined) {\r\n        const node = new __XmlNode(\"HostName\").addChildNode(new __XmlText(input.HostName)).withName(\"HostName\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.HttpRedirectCode !== undefined) {\r\n        const node = new __XmlNode(\"HttpRedirectCode\")\r\n            .addChildNode(new __XmlText(input.HttpRedirectCode))\r\n            .withName(\"HttpRedirectCode\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRedirectAllRequestsTo = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"RedirectAllRequestsTo\");\r\n    if (input.Protocol !== undefined) {\r\n        const node = new __XmlNode(\"Protocol\").addChildNode(new __XmlText(input.Protocol)).withName(\"Protocol\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.HostName !== undefined) {\r\n        const node = new __XmlNode(\"HostName\").addChildNode(new __XmlText(input.HostName)).withName(\"HostName\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationConfiguration\");\r\n    if (input.Role !== undefined) {\r\n        const node = new __XmlNode(\"Role\").addChildNode(new __XmlText(input.Role)).withName(\"Role\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Rules !== undefined) {\r\n        const nodes = serializeAws_restXmlReplicationRules(input.Rules, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Rule\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationRule\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"ReplicationRuleStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Priority !== undefined) {\r\n        const node = new __XmlNode(\"Priority\").addChildNode(new __XmlText(String(input.Priority))).withName(\"Priority\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Destination !== undefined) {\r\n        const node = serializeAws_restXmlDestination(input.Destination, context).withName(\"Destination\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ID !== undefined) {\r\n        const node = new __XmlNode(\"ID\").addChildNode(new __XmlText(input.ID)).withName(\"ID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.SourceSelectionCriteria !== undefined) {\r\n        const node = serializeAws_restXmlSourceSelectionCriteria(input.SourceSelectionCriteria, context).withName(\"SourceSelectionCriteria\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlReplicationRuleFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ExistingObjectReplication !== undefined) {\r\n        const node = serializeAws_restXmlExistingObjectReplication(input.ExistingObjectReplication, context).withName(\"ExistingObjectReplication\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.DeleteMarkerReplication !== undefined) {\r\n        const node = serializeAws_restXmlDeleteMarkerReplication(input.DeleteMarkerReplication, context).withName(\"DeleteMarkerReplication\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationRuleAndOperator = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationRuleAndOperator\");\r\n    if (input.Tags !== undefined) {\r\n        const nodes = serializeAws_restXmlTagSet(input.Tags, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Tag\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationRuleFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationRuleFilter\");\r\n    if (input.And !== undefined) {\r\n        const node = serializeAws_restXmlReplicationRuleAndOperator(input.And, context).withName(\"And\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"Prefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tag !== undefined) {\r\n        const node = serializeAws_restXmlTag(input.Tag, context).withName(\"Tag\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationRules = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlReplicationRule(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlReplicationTime = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationTime\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"ReplicationTimeStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Time !== undefined) {\r\n        const node = serializeAws_restXmlReplicationTimeValue(input.Time, context).withName(\"Time\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlReplicationTimeValue = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ReplicationTimeValue\");\r\n    if (input.Minutes !== undefined) {\r\n        const node = new __XmlNode(\"Minutes\").addChildNode(new __XmlText(String(input.Minutes))).withName(\"Minutes\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRequestPaymentConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"RequestPaymentConfiguration\");\r\n    if (input.Payer !== undefined) {\r\n        const node = new __XmlNode(\"Payer\").addChildNode(new __XmlText(input.Payer)).withName(\"Payer\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRequestProgress = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"RequestProgress\");\r\n    if (input.Enabled !== undefined) {\r\n        const node = new __XmlNode(\"EnableRequestProgress\")\r\n            .addChildNode(new __XmlText(String(input.Enabled)))\r\n            .withName(\"Enabled\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRestoreRequest = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"RestoreRequest\");\r\n    if (input.Description !== undefined) {\r\n        const node = new __XmlNode(\"Description\").addChildNode(new __XmlText(input.Description)).withName(\"Description\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.GlacierJobParameters !== undefined) {\r\n        const node = serializeAws_restXmlGlacierJobParameters(input.GlacierJobParameters, context).withName(\"GlacierJobParameters\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Tier !== undefined) {\r\n        const node = new __XmlNode(\"Tier\").addChildNode(new __XmlText(input.Tier)).withName(\"Tier\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Days !== undefined) {\r\n        const node = new __XmlNode(\"Days\").addChildNode(new __XmlText(String(input.Days))).withName(\"Days\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.OutputLocation !== undefined) {\r\n        const node = serializeAws_restXmlOutputLocation(input.OutputLocation, context).withName(\"OutputLocation\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.SelectParameters !== undefined) {\r\n        const node = serializeAws_restXmlSelectParameters(input.SelectParameters, context).withName(\"SelectParameters\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Type !== undefined) {\r\n        const node = new __XmlNode(\"RestoreRequestType\").addChildNode(new __XmlText(input.Type)).withName(\"Type\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRoutingRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"RoutingRule\");\r\n    if (input.Condition !== undefined) {\r\n        const node = serializeAws_restXmlCondition(input.Condition, context).withName(\"Condition\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Redirect !== undefined) {\r\n        const node = serializeAws_restXmlRedirect(input.Redirect, context).withName(\"Redirect\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlRoutingRules = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlRoutingRule(entry, context);\r\n        return node.withName(\"RoutingRule\");\r\n    });\r\n};\r\nconst serializeAws_restXmlS3KeyFilter = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"S3KeyFilter\");\r\n    if (input.FilterRules !== undefined) {\r\n        const nodes = serializeAws_restXmlFilterRuleList(input.FilterRules, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"FilterRule\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlS3Location = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"S3Location\");\r\n    if (input.UserMetadata !== undefined) {\r\n        const nodes = serializeAws_restXmlUserMetadata(input.UserMetadata, context);\r\n        const containerNode = new __XmlNode(\"UserMetadata\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    if (input.StorageClass !== undefined) {\r\n        const node = new __XmlNode(\"StorageClass\").addChildNode(new __XmlText(input.StorageClass)).withName(\"StorageClass\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.CannedACL !== undefined) {\r\n        const node = new __XmlNode(\"ObjectCannedACL\").addChildNode(new __XmlText(input.CannedACL)).withName(\"CannedACL\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Encryption !== undefined) {\r\n        const node = serializeAws_restXmlEncryption(input.Encryption, context).withName(\"Encryption\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Prefix !== undefined) {\r\n        const node = new __XmlNode(\"LocationPrefix\").addChildNode(new __XmlText(input.Prefix)).withName(\"Prefix\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.BucketName !== undefined) {\r\n        const node = new __XmlNode(\"BucketName\").addChildNode(new __XmlText(input.BucketName)).withName(\"BucketName\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.AccessControlList !== undefined) {\r\n        const nodes = serializeAws_restXmlGrants(input.AccessControlList, context);\r\n        const containerNode = new __XmlNode(\"AccessControlList\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    if (input.Tagging !== undefined) {\r\n        const node = serializeAws_restXmlTagging(input.Tagging, context).withName(\"Tagging\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlScanRange = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ScanRange\");\r\n    if (input.Start !== undefined) {\r\n        const node = new __XmlNode(\"Start\").addChildNode(new __XmlText(String(input.Start))).withName(\"Start\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.End !== undefined) {\r\n        const node = new __XmlNode(\"End\").addChildNode(new __XmlText(String(input.End))).withName(\"End\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlSelectParameters = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"SelectParameters\");\r\n    if (input.Expression !== undefined) {\r\n        const node = new __XmlNode(\"Expression\").addChildNode(new __XmlText(input.Expression)).withName(\"Expression\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.InputSerialization !== undefined) {\r\n        const node = serializeAws_restXmlInputSerialization(input.InputSerialization, context).withName(\"InputSerialization\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ExpressionType !== undefined) {\r\n        const node = new __XmlNode(\"ExpressionType\")\r\n            .addChildNode(new __XmlText(input.ExpressionType))\r\n            .withName(\"ExpressionType\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.OutputSerialization !== undefined) {\r\n        const node = serializeAws_restXmlOutputSerialization(input.OutputSerialization, context).withName(\"OutputSerialization\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlServerSideEncryptionByDefault = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ServerSideEncryptionByDefault\");\r\n    if (input.KMSMasterKeyID !== undefined) {\r\n        const node = new __XmlNode(\"SSEKMSKeyId\")\r\n            .addChildNode(new __XmlText(input.KMSMasterKeyID))\r\n            .withName(\"KMSMasterKeyID\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.SSEAlgorithm !== undefined) {\r\n        const node = new __XmlNode(\"ServerSideEncryption\")\r\n            .addChildNode(new __XmlText(input.SSEAlgorithm))\r\n            .withName(\"SSEAlgorithm\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlServerSideEncryptionConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ServerSideEncryptionConfiguration\");\r\n    if (input.Rules !== undefined) {\r\n        const nodes = serializeAws_restXmlServerSideEncryptionRules(input.Rules, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Rule\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlServerSideEncryptionRule = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"ServerSideEncryptionRule\");\r\n    if (input.ApplyServerSideEncryptionByDefault !== undefined) {\r\n        const node = serializeAws_restXmlServerSideEncryptionByDefault(input.ApplyServerSideEncryptionByDefault, context).withName(\"ApplyServerSideEncryptionByDefault\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlServerSideEncryptionRules = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlServerSideEncryptionRule(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlSourceSelectionCriteria = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"SourceSelectionCriteria\");\r\n    if (input.SseKmsEncryptedObjects !== undefined) {\r\n        const node = serializeAws_restXmlSseKmsEncryptedObjects(input.SseKmsEncryptedObjects, context).withName(\"SseKmsEncryptedObjects\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlSSEKMS = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"SSE-KMS\");\r\n    if (input.KeyId !== undefined) {\r\n        const node = new __XmlNode(\"SSEKMSKeyId\").addChildNode(new __XmlText(input.KeyId)).withName(\"KeyId\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlSseKmsEncryptedObjects = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"SseKmsEncryptedObjects\");\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"SseKmsEncryptedObjectsStatus\")\r\n            .addChildNode(new __XmlText(input.Status))\r\n            .withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlSSES3 = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"SSE-S3\");\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlStorageClassAnalysis = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"StorageClassAnalysis\");\r\n    if (input.DataExport !== undefined) {\r\n        const node = serializeAws_restXmlStorageClassAnalysisDataExport(input.DataExport, context).withName(\"DataExport\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlStorageClassAnalysisDataExport = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"StorageClassAnalysisDataExport\");\r\n    if (input.Destination !== undefined) {\r\n        const node = serializeAws_restXmlAnalyticsExportDestination(input.Destination, context).withName(\"Destination\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.OutputSchemaVersion !== undefined) {\r\n        const node = new __XmlNode(\"StorageClassAnalysisSchemaVersion\")\r\n            .addChildNode(new __XmlText(input.OutputSchemaVersion))\r\n            .withName(\"OutputSchemaVersion\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTag = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Tag\");\r\n    if (input.Key !== undefined) {\r\n        const node = new __XmlNode(\"ObjectKey\").addChildNode(new __XmlText(input.Key)).withName(\"Key\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Value !== undefined) {\r\n        const node = new __XmlNode(\"Value\").addChildNode(new __XmlText(input.Value)).withName(\"Value\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTagging = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Tagging\");\r\n    if (input.TagSet !== undefined) {\r\n        const nodes = serializeAws_restXmlTagSet(input.TagSet, context);\r\n        const containerNode = new __XmlNode(\"TagSet\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTagSet = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlTag(entry, context);\r\n        return node.withName(\"Tag\");\r\n    });\r\n};\r\nconst serializeAws_restXmlTargetGrant = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"TargetGrant\");\r\n    if (input.Grantee !== undefined) {\r\n        const node = serializeAws_restXmlGrantee(input.Grantee, context).withName(\"Grantee\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Permission !== undefined) {\r\n        const node = new __XmlNode(\"BucketLogsPermission\")\r\n            .addChildNode(new __XmlText(input.Permission))\r\n            .withName(\"Permission\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTargetGrants = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlTargetGrant(entry, context);\r\n        return node.withName(\"Grant\");\r\n    });\r\n};\r\nconst serializeAws_restXmlTopicConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"TopicConfiguration\");\r\n    if (input.TopicArn !== undefined) {\r\n        const node = new __XmlNode(\"TopicArn\").addChildNode(new __XmlText(input.TopicArn)).withName(\"Topic\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Id !== undefined) {\r\n        const node = new __XmlNode(\"NotificationId\").addChildNode(new __XmlText(input.Id)).withName(\"Id\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Filter !== undefined) {\r\n        const node = serializeAws_restXmlNotificationConfigurationFilter(input.Filter, context).withName(\"Filter\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Events !== undefined) {\r\n        const nodes = serializeAws_restXmlEventList(input.Events, context);\r\n        nodes.map((node) => {\r\n            node = node.withName(\"Event\");\r\n            bodyNode.addChildNode(node);\r\n        });\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTopicConfigurationList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlTopicConfiguration(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlTransition = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"Transition\");\r\n    if (input.Date !== undefined) {\r\n        const node = new __XmlNode(\"Date\")\r\n            .addChildNode(new __XmlText(input.Date.toISOString().split(\".\")[0] + \"Z\"))\r\n            .withName(\"Date\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Days !== undefined) {\r\n        const node = new __XmlNode(\"Days\").addChildNode(new __XmlText(String(input.Days))).withName(\"Days\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.StorageClass !== undefined) {\r\n        const node = new __XmlNode(\"TransitionStorageClass\")\r\n            .addChildNode(new __XmlText(input.StorageClass))\r\n            .withName(\"StorageClass\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlTransitionList = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlTransition(entry, context);\r\n        return node.withName(\"member\");\r\n    });\r\n};\r\nconst serializeAws_restXmlUserMetadata = (input, context) => {\r\n    return input.map((entry) => {\r\n        const node = serializeAws_restXmlMetadataEntry(entry, context);\r\n        return node.withName(\"MetadataEntry\");\r\n    });\r\n};\r\nconst serializeAws_restXmlVersioningConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"VersioningConfiguration\");\r\n    if (input.MFADelete !== undefined) {\r\n        const node = new __XmlNode(\"MFADelete\").addChildNode(new __XmlText(input.MFADelete)).withName(\"MfaDelete\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.Status !== undefined) {\r\n        const node = new __XmlNode(\"BucketVersioningStatus\").addChildNode(new __XmlText(input.Status)).withName(\"Status\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst serializeAws_restXmlWebsiteConfiguration = (input, context) => {\r\n    const bodyNode = new __XmlNode(\"WebsiteConfiguration\");\r\n    if (input.RoutingRules !== undefined) {\r\n        const nodes = serializeAws_restXmlRoutingRules(input.RoutingRules, context);\r\n        const containerNode = new __XmlNode(\"RoutingRules\");\r\n        nodes.map((node) => {\r\n            containerNode.addChildNode(node);\r\n        });\r\n        bodyNode.addChildNode(containerNode);\r\n    }\r\n    if (input.IndexDocument !== undefined) {\r\n        const node = serializeAws_restXmlIndexDocument(input.IndexDocument, context).withName(\"IndexDocument\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.RedirectAllRequestsTo !== undefined) {\r\n        const node = serializeAws_restXmlRedirectAllRequestsTo(input.RedirectAllRequestsTo, context).withName(\"RedirectAllRequestsTo\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    if (input.ErrorDocument !== undefined) {\r\n        const node = serializeAws_restXmlErrorDocument(input.ErrorDocument, context).withName(\"ErrorDocument\");\r\n        bodyNode.addChildNode(node);\r\n    }\r\n    return bodyNode;\r\n};\r\nconst deserializeAws_restXmlAbortIncompleteMultipartUpload = (output, context) => {\r\n    let contents = {\r\n        __type: \"AbortIncompleteMultipartUpload\",\r\n        DaysAfterInitiation: undefined,\r\n    };\r\n    if (output[\"DaysAfterInitiation\"] !== undefined) {\r\n        contents.DaysAfterInitiation = parseInt(output[\"DaysAfterInitiation\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAccessControlTranslation = (output, context) => {\r\n    let contents = {\r\n        __type: \"AccessControlTranslation\",\r\n        Owner: undefined,\r\n    };\r\n    if (output[\"Owner\"] !== undefined) {\r\n        contents.Owner = output[\"Owner\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAllowedHeaders = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlAllowedMethods = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlAllowedOrigins = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlAnalyticsAndOperator = (output, context) => {\r\n    let contents = {\r\n        __type: \"AnalyticsAndOperator\",\r\n        Tags: undefined,\r\n        Prefix: undefined,\r\n    };\r\n    if (output.Tag === \"\") {\r\n        contents.Tags = [];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tags = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(output[\"Tag\"]), context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAnalyticsConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"AnalyticsConfiguration\",\r\n        StorageClassAnalysis: undefined,\r\n        Filter: undefined,\r\n        Id: undefined,\r\n    };\r\n    if (output[\"StorageClassAnalysis\"] !== undefined) {\r\n        contents.StorageClassAnalysis = deserializeAws_restXmlStorageClassAnalysis(output[\"StorageClassAnalysis\"], context);\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlAnalyticsFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAnalyticsConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlAnalyticsConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlAnalyticsExportDestination = (output, context) => {\r\n    let contents = {\r\n        __type: \"AnalyticsExportDestination\",\r\n        S3BucketDestination: undefined,\r\n    };\r\n    if (output[\"S3BucketDestination\"] !== undefined) {\r\n        contents.S3BucketDestination = deserializeAws_restXmlAnalyticsS3BucketDestination(output[\"S3BucketDestination\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAnalyticsFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"AnalyticsFilter\",\r\n        And: undefined,\r\n        Prefix: undefined,\r\n        Tag: undefined,\r\n    };\r\n    if (output[\"And\"] !== undefined) {\r\n        contents.And = deserializeAws_restXmlAnalyticsAndOperator(output[\"And\"], context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tag = deserializeAws_restXmlTag(output[\"Tag\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlAnalyticsS3BucketDestination = (output, context) => {\r\n    let contents = {\r\n        __type: \"AnalyticsS3BucketDestination\",\r\n        Format: undefined,\r\n        Prefix: undefined,\r\n        Bucket: undefined,\r\n        BucketAccountId: undefined,\r\n    };\r\n    if (output[\"Format\"] !== undefined) {\r\n        contents.Format = output[\"Format\"];\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = output[\"Bucket\"];\r\n    }\r\n    if (output[\"BucketAccountId\"] !== undefined) {\r\n        contents.BucketAccountId = output[\"BucketAccountId\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlBucket = (output, context) => {\r\n    let contents = {\r\n        __type: \"Bucket\",\r\n        CreationDate: undefined,\r\n        Name: undefined,\r\n    };\r\n    if (output[\"CreationDate\"] !== undefined) {\r\n        contents.CreationDate = new Date(output[\"CreationDate\"]);\r\n    }\r\n    if (output[\"Name\"] !== undefined) {\r\n        contents.Name = output[\"Name\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlBuckets = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlBucket(entry, context));\r\n};\r\nconst deserializeAws_restXmlCommonPrefix = (output, context) => {\r\n    let contents = {\r\n        __type: \"CommonPrefix\",\r\n        Prefix: undefined,\r\n    };\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlCommonPrefixList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlCommonPrefix(entry, context));\r\n};\r\nconst deserializeAws_restXmlCondition = (output, context) => {\r\n    let contents = {\r\n        __type: \"Condition\",\r\n        KeyPrefixEquals: undefined,\r\n        HttpErrorCodeReturnedEquals: undefined,\r\n    };\r\n    if (output[\"KeyPrefixEquals\"] !== undefined) {\r\n        contents.KeyPrefixEquals = output[\"KeyPrefixEquals\"];\r\n    }\r\n    if (output[\"HttpErrorCodeReturnedEquals\"] !== undefined) {\r\n        contents.HttpErrorCodeReturnedEquals = output[\"HttpErrorCodeReturnedEquals\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlCopyObjectResult = (output, context) => {\r\n    let contents = {\r\n        __type: \"CopyObjectResult\",\r\n        LastModified: undefined,\r\n        ETag: undefined,\r\n    };\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    if (output[\"ETag\"] !== undefined) {\r\n        contents.ETag = output[\"ETag\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlCopyPartResult = (output, context) => {\r\n    let contents = {\r\n        __type: \"CopyPartResult\",\r\n        ETag: undefined,\r\n        LastModified: undefined,\r\n    };\r\n    if (output[\"ETag\"] !== undefined) {\r\n        contents.ETag = output[\"ETag\"];\r\n    }\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlCORSRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"CORSRule\",\r\n        MaxAgeSeconds: undefined,\r\n        AllowedOrigins: undefined,\r\n        AllowedHeaders: undefined,\r\n        AllowedMethods: undefined,\r\n        ExposeHeaders: undefined,\r\n    };\r\n    if (output[\"MaxAgeSeconds\"] !== undefined) {\r\n        contents.MaxAgeSeconds = parseInt(output[\"MaxAgeSeconds\"]);\r\n    }\r\n    if (output.AllowedOrigin === \"\") {\r\n        contents.AllowedOrigins = [];\r\n    }\r\n    if (output[\"AllowedOrigin\"] !== undefined) {\r\n        contents.AllowedOrigins = deserializeAws_restXmlAllowedOrigins(__getArrayIfSingleItem(output[\"AllowedOrigin\"]), context);\r\n    }\r\n    if (output.AllowedHeader === \"\") {\r\n        contents.AllowedHeaders = [];\r\n    }\r\n    if (output[\"AllowedHeader\"] !== undefined) {\r\n        contents.AllowedHeaders = deserializeAws_restXmlAllowedHeaders(__getArrayIfSingleItem(output[\"AllowedHeader\"]), context);\r\n    }\r\n    if (output.AllowedMethod === \"\") {\r\n        contents.AllowedMethods = [];\r\n    }\r\n    if (output[\"AllowedMethod\"] !== undefined) {\r\n        contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(__getArrayIfSingleItem(output[\"AllowedMethod\"]), context);\r\n    }\r\n    if (output.ExposeHeader === \"\") {\r\n        contents.ExposeHeaders = [];\r\n    }\r\n    if (output[\"ExposeHeader\"] !== undefined) {\r\n        contents.ExposeHeaders = deserializeAws_restXmlExposeHeaders(__getArrayIfSingleItem(output[\"ExposeHeader\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlCORSRules = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlCORSRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlDefaultRetention = (output, context) => {\r\n    let contents = {\r\n        __type: \"DefaultRetention\",\r\n        Mode: undefined,\r\n        Days: undefined,\r\n        Years: undefined,\r\n    };\r\n    if (output[\"Mode\"] !== undefined) {\r\n        contents.Mode = output[\"Mode\"];\r\n    }\r\n    if (output[\"Days\"] !== undefined) {\r\n        contents.Days = parseInt(output[\"Days\"]);\r\n    }\r\n    if (output[\"Years\"] !== undefined) {\r\n        contents.Years = parseInt(output[\"Years\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlDeletedObject = (output, context) => {\r\n    let contents = {\r\n        __type: \"DeletedObject\",\r\n        Key: undefined,\r\n        DeleteMarkerVersionId: undefined,\r\n        DeleteMarker: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    if (output[\"DeleteMarkerVersionId\"] !== undefined) {\r\n        contents.DeleteMarkerVersionId = output[\"DeleteMarkerVersionId\"];\r\n    }\r\n    if (output[\"DeleteMarker\"] !== undefined) {\r\n        contents.DeleteMarker = output[\"DeleteMarker\"] == \"true\";\r\n    }\r\n    if (output[\"VersionId\"] !== undefined) {\r\n        contents.VersionId = output[\"VersionId\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlDeletedObjects = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlDeletedObject(entry, context));\r\n};\r\nconst deserializeAws_restXmlDeleteMarkerEntry = (output, context) => {\r\n    let contents = {\r\n        __type: \"DeleteMarkerEntry\",\r\n        VersionId: undefined,\r\n        LastModified: undefined,\r\n        Owner: undefined,\r\n        IsLatest: undefined,\r\n        Key: undefined,\r\n    };\r\n    if (output[\"VersionId\"] !== undefined) {\r\n        contents.VersionId = output[\"VersionId\"];\r\n    }\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    if (output[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(output[\"Owner\"], context);\r\n    }\r\n    if (output[\"IsLatest\"] !== undefined) {\r\n        contents.IsLatest = output[\"IsLatest\"] == \"true\";\r\n    }\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlDeleteMarkerReplication = (output, context) => {\r\n    let contents = {\r\n        __type: \"DeleteMarkerReplication\",\r\n        Status: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlDeleteMarkers = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlDeleteMarkerEntry(entry, context));\r\n};\r\nconst deserializeAws_restXmlDestination = (output, context) => {\r\n    let contents = {\r\n        __type: \"Destination\",\r\n        StorageClass: undefined,\r\n        Metrics: undefined,\r\n        ReplicationTime: undefined,\r\n        Account: undefined,\r\n        EncryptionConfiguration: undefined,\r\n        Bucket: undefined,\r\n        AccessControlTranslation: undefined,\r\n    };\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    if (output[\"Metrics\"] !== undefined) {\r\n        contents.Metrics = deserializeAws_restXmlMetrics(output[\"Metrics\"], context);\r\n    }\r\n    if (output[\"ReplicationTime\"] !== undefined) {\r\n        contents.ReplicationTime = deserializeAws_restXmlReplicationTime(output[\"ReplicationTime\"], context);\r\n    }\r\n    if (output[\"Account\"] !== undefined) {\r\n        contents.Account = output[\"Account\"];\r\n    }\r\n    if (output[\"EncryptionConfiguration\"] !== undefined) {\r\n        contents.EncryptionConfiguration = deserializeAws_restXmlEncryptionConfiguration(output[\"EncryptionConfiguration\"], context);\r\n    }\r\n    if (output[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = output[\"Bucket\"];\r\n    }\r\n    if (output[\"AccessControlTranslation\"] !== undefined) {\r\n        contents.AccessControlTranslation = deserializeAws_restXmlAccessControlTranslation(output[\"AccessControlTranslation\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlEncryptionConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"EncryptionConfiguration\",\r\n        ReplicaKmsKeyID: undefined,\r\n    };\r\n    if (output[\"ReplicaKmsKeyID\"] !== undefined) {\r\n        contents.ReplicaKmsKeyID = output[\"ReplicaKmsKeyID\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXml_Error = (output, context) => {\r\n    let contents = {\r\n        __type: \"Error\",\r\n        Key: undefined,\r\n        Code: undefined,\r\n        Message: undefined,\r\n        VersionId: undefined,\r\n    };\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    if (output[\"Code\"] !== undefined) {\r\n        contents.Code = output[\"Code\"];\r\n    }\r\n    if (output[\"Message\"] !== undefined) {\r\n        contents.Message = output[\"Message\"];\r\n    }\r\n    if (output[\"VersionId\"] !== undefined) {\r\n        contents.VersionId = output[\"VersionId\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlErrorDocument = (output, context) => {\r\n    let contents = {\r\n        __type: \"ErrorDocument\",\r\n        Key: undefined,\r\n    };\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlErrors = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXml_Error(entry, context));\r\n};\r\nconst deserializeAws_restXmlEventList = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlExistingObjectReplication = (output, context) => {\r\n    let contents = {\r\n        __type: \"ExistingObjectReplication\",\r\n        Status: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlExposeHeaders = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlFilterRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"FilterRule\",\r\n        Name: undefined,\r\n        Value: undefined,\r\n    };\r\n    if (output[\"Name\"] !== undefined) {\r\n        contents.Name = output[\"Name\"];\r\n    }\r\n    if (output[\"Value\"] !== undefined) {\r\n        contents.Value = output[\"Value\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlFilterRuleList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlFilterRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlGrant = (output, context) => {\r\n    let contents = {\r\n        __type: \"Grant\",\r\n        Permission: undefined,\r\n        Grantee: undefined,\r\n    };\r\n    if (output[\"Permission\"] !== undefined) {\r\n        contents.Permission = output[\"Permission\"];\r\n    }\r\n    if (output[\"Grantee\"] !== undefined) {\r\n        contents.Grantee = deserializeAws_restXmlGrantee(output[\"Grantee\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlGrantee = (output, context) => {\r\n    let contents = {\r\n        __type: \"Grantee\",\r\n        ID: undefined,\r\n        DisplayName: undefined,\r\n        EmailAddress: undefined,\r\n        URI: undefined,\r\n        Type: undefined,\r\n    };\r\n    if (output[\"ID\"] !== undefined) {\r\n        contents.ID = output[\"ID\"];\r\n    }\r\n    if (output[\"DisplayName\"] !== undefined) {\r\n        contents.DisplayName = output[\"DisplayName\"];\r\n    }\r\n    if (output[\"EmailAddress\"] !== undefined) {\r\n        contents.EmailAddress = output[\"EmailAddress\"];\r\n    }\r\n    if (output[\"URI\"] !== undefined) {\r\n        contents.URI = output[\"URI\"];\r\n    }\r\n    if (output[\"xsi:type\"] !== undefined) {\r\n        contents.Type = output[\"xsi:type\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlGrants = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlGrant(entry, context));\r\n};\r\nconst deserializeAws_restXmlIndexDocument = (output, context) => {\r\n    let contents = {\r\n        __type: \"IndexDocument\",\r\n        Suffix: undefined,\r\n    };\r\n    if (output[\"Suffix\"] !== undefined) {\r\n        contents.Suffix = output[\"Suffix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInitiator = (output, context) => {\r\n    let contents = {\r\n        __type: \"Initiator\",\r\n        ID: undefined,\r\n        DisplayName: undefined,\r\n    };\r\n    if (output[\"ID\"] !== undefined) {\r\n        contents.ID = output[\"ID\"];\r\n    }\r\n    if (output[\"DisplayName\"] !== undefined) {\r\n        contents.DisplayName = output[\"DisplayName\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventoryConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventoryConfiguration\",\r\n        OptionalFields: undefined,\r\n        Destination: undefined,\r\n        Id: undefined,\r\n        Filter: undefined,\r\n        Schedule: undefined,\r\n        IsEnabled: undefined,\r\n        IncludedObjectVersions: undefined,\r\n    };\r\n    if (output.OptionalFields === \"\") {\r\n        contents.OptionalFields = [];\r\n    }\r\n    if (output[\"OptionalFields\"] !== undefined && output[\"OptionalFields\"][\"Field\"] !== undefined) {\r\n        contents.OptionalFields = deserializeAws_restXmlInventoryOptionalFields(__getArrayIfSingleItem(output[\"OptionalFields\"][\"Field\"]), context);\r\n    }\r\n    if (output[\"Destination\"] !== undefined) {\r\n        contents.Destination = deserializeAws_restXmlInventoryDestination(output[\"Destination\"], context);\r\n    }\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlInventoryFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output[\"Schedule\"] !== undefined) {\r\n        contents.Schedule = deserializeAws_restXmlInventorySchedule(output[\"Schedule\"], context);\r\n    }\r\n    if (output[\"IsEnabled\"] !== undefined) {\r\n        contents.IsEnabled = output[\"IsEnabled\"] == \"true\";\r\n    }\r\n    if (output[\"IncludedObjectVersions\"] !== undefined) {\r\n        contents.IncludedObjectVersions = output[\"IncludedObjectVersions\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventoryConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlInventoryConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlInventoryDestination = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventoryDestination\",\r\n        S3BucketDestination: undefined,\r\n    };\r\n    if (output[\"S3BucketDestination\"] !== undefined) {\r\n        contents.S3BucketDestination = deserializeAws_restXmlInventoryS3BucketDestination(output[\"S3BucketDestination\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventoryEncryption = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventoryEncryption\",\r\n        SSES3: undefined,\r\n        SSEKMS: undefined,\r\n    };\r\n    if (output[\"SSE-S3\"] !== undefined) {\r\n        contents.SSES3 = deserializeAws_restXmlSSES3(output[\"SSE-S3\"], context);\r\n    }\r\n    if (output[\"SSE-KMS\"] !== undefined) {\r\n        contents.SSEKMS = deserializeAws_restXmlSSEKMS(output[\"SSE-KMS\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventoryFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventoryFilter\",\r\n        Prefix: undefined,\r\n    };\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventoryOptionalFields = (output, context) => {\r\n    return (output || []).map((entry) => entry);\r\n};\r\nconst deserializeAws_restXmlInventoryS3BucketDestination = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventoryS3BucketDestination\",\r\n        Bucket: undefined,\r\n        AccountId: undefined,\r\n        Encryption: undefined,\r\n        Prefix: undefined,\r\n        Format: undefined,\r\n    };\r\n    if (output[\"Bucket\"] !== undefined) {\r\n        contents.Bucket = output[\"Bucket\"];\r\n    }\r\n    if (output[\"AccountId\"] !== undefined) {\r\n        contents.AccountId = output[\"AccountId\"];\r\n    }\r\n    if (output[\"Encryption\"] !== undefined) {\r\n        contents.Encryption = deserializeAws_restXmlInventoryEncryption(output[\"Encryption\"], context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Format\"] !== undefined) {\r\n        contents.Format = output[\"Format\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlInventorySchedule = (output, context) => {\r\n    let contents = {\r\n        __type: \"InventorySchedule\",\r\n        Frequency: undefined,\r\n    };\r\n    if (output[\"Frequency\"] !== undefined) {\r\n        contents.Frequency = output[\"Frequency\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLambdaFunctionConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"LambdaFunctionConfiguration\",\r\n        LambdaFunctionArn: undefined,\r\n        Id: undefined,\r\n        Events: undefined,\r\n        Filter: undefined,\r\n    };\r\n    if (output[\"CloudFunction\"] !== undefined) {\r\n        contents.LambdaFunctionArn = output[\"CloudFunction\"];\r\n    }\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    if (output.Event === \"\") {\r\n        contents.Events = [];\r\n    }\r\n    if (output[\"Event\"] !== undefined) {\r\n        contents.Events = deserializeAws_restXmlEventList(__getArrayIfSingleItem(output[\"Event\"]), context);\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(output[\"Filter\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLambdaFunctionConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlLambdaFunctionConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlLifecycleExpiration = (output, context) => {\r\n    let contents = {\r\n        __type: \"LifecycleExpiration\",\r\n        Date: undefined,\r\n        ExpiredObjectDeleteMarker: undefined,\r\n        Days: undefined,\r\n    };\r\n    if (output[\"Date\"] !== undefined) {\r\n        contents.Date = new Date(output[\"Date\"]);\r\n    }\r\n    if (output[\"ExpiredObjectDeleteMarker\"] !== undefined) {\r\n        contents.ExpiredObjectDeleteMarker = output[\"ExpiredObjectDeleteMarker\"] == \"true\";\r\n    }\r\n    if (output[\"Days\"] !== undefined) {\r\n        contents.Days = parseInt(output[\"Days\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLifecycleRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"LifecycleRule\",\r\n        ID: undefined,\r\n        Status: undefined,\r\n        AbortIncompleteMultipartUpload: undefined,\r\n        NoncurrentVersionTransitions: undefined,\r\n        Prefix: undefined,\r\n        Transitions: undefined,\r\n        Filter: undefined,\r\n        Expiration: undefined,\r\n        NoncurrentVersionExpiration: undefined,\r\n    };\r\n    if (output[\"ID\"] !== undefined) {\r\n        contents.ID = output[\"ID\"];\r\n    }\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    if (output[\"AbortIncompleteMultipartUpload\"] !== undefined) {\r\n        contents.AbortIncompleteMultipartUpload = deserializeAws_restXmlAbortIncompleteMultipartUpload(output[\"AbortIncompleteMultipartUpload\"], context);\r\n    }\r\n    if (output.NoncurrentVersionTransition === \"\") {\r\n        contents.NoncurrentVersionTransitions = [];\r\n    }\r\n    if (output[\"NoncurrentVersionTransition\"] !== undefined) {\r\n        contents.NoncurrentVersionTransitions = deserializeAws_restXmlNoncurrentVersionTransitionList(__getArrayIfSingleItem(output[\"NoncurrentVersionTransition\"]), context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output.Transition === \"\") {\r\n        contents.Transitions = [];\r\n    }\r\n    if (output[\"Transition\"] !== undefined) {\r\n        contents.Transitions = deserializeAws_restXmlTransitionList(__getArrayIfSingleItem(output[\"Transition\"]), context);\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlLifecycleRuleFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output[\"Expiration\"] !== undefined) {\r\n        contents.Expiration = deserializeAws_restXmlLifecycleExpiration(output[\"Expiration\"], context);\r\n    }\r\n    if (output[\"NoncurrentVersionExpiration\"] !== undefined) {\r\n        contents.NoncurrentVersionExpiration = deserializeAws_restXmlNoncurrentVersionExpiration(output[\"NoncurrentVersionExpiration\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLifecycleRuleAndOperator = (output, context) => {\r\n    let contents = {\r\n        __type: \"LifecycleRuleAndOperator\",\r\n        Tags: undefined,\r\n        Prefix: undefined,\r\n    };\r\n    if (output.Tag === \"\") {\r\n        contents.Tags = [];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tags = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(output[\"Tag\"]), context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLifecycleRuleFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"LifecycleRuleFilter\",\r\n        And: undefined,\r\n        Prefix: undefined,\r\n        Tag: undefined,\r\n    };\r\n    if (output[\"And\"] !== undefined) {\r\n        contents.And = deserializeAws_restXmlLifecycleRuleAndOperator(output[\"And\"], context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tag = deserializeAws_restXmlTag(output[\"Tag\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlLifecycleRules = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlLifecycleRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlLoggingEnabled = (output, context) => {\r\n    let contents = {\r\n        __type: \"LoggingEnabled\",\r\n        TargetBucket: undefined,\r\n        TargetPrefix: undefined,\r\n        TargetGrants: undefined,\r\n    };\r\n    if (output[\"TargetBucket\"] !== undefined) {\r\n        contents.TargetBucket = output[\"TargetBucket\"];\r\n    }\r\n    if (output[\"TargetPrefix\"] !== undefined) {\r\n        contents.TargetPrefix = output[\"TargetPrefix\"];\r\n    }\r\n    if (output.TargetGrants === \"\") {\r\n        contents.TargetGrants = [];\r\n    }\r\n    if (output[\"TargetGrants\"] !== undefined && output[\"TargetGrants\"][\"Grant\"] !== undefined) {\r\n        contents.TargetGrants = deserializeAws_restXmlTargetGrants(__getArrayIfSingleItem(output[\"TargetGrants\"][\"Grant\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMetrics = (output, context) => {\r\n    let contents = {\r\n        __type: \"Metrics\",\r\n        EventThreshold: undefined,\r\n        Status: undefined,\r\n    };\r\n    if (output[\"EventThreshold\"] !== undefined) {\r\n        contents.EventThreshold = deserializeAws_restXmlReplicationTimeValue(output[\"EventThreshold\"], context);\r\n    }\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMetricsAndOperator = (output, context) => {\r\n    let contents = {\r\n        __type: \"MetricsAndOperator\",\r\n        Prefix: undefined,\r\n        Tags: undefined,\r\n    };\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output.Tag === \"\") {\r\n        contents.Tags = [];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tags = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(output[\"Tag\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMetricsConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"MetricsConfiguration\",\r\n        Filter: undefined,\r\n        Id: undefined,\r\n    };\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlMetricsFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMetricsConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlMetricsConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlMetricsFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"MetricsFilter\",\r\n        Prefix: undefined,\r\n        And: undefined,\r\n        Tag: undefined,\r\n    };\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"And\"] !== undefined) {\r\n        contents.And = deserializeAws_restXmlMetricsAndOperator(output[\"And\"], context);\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tag = deserializeAws_restXmlTag(output[\"Tag\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMultipartUpload = (output, context) => {\r\n    let contents = {\r\n        __type: \"MultipartUpload\",\r\n        Key: undefined,\r\n        UploadId: undefined,\r\n        Initiated: undefined,\r\n        Owner: undefined,\r\n        Initiator: undefined,\r\n        StorageClass: undefined,\r\n    };\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    if (output[\"UploadId\"] !== undefined) {\r\n        contents.UploadId = output[\"UploadId\"];\r\n    }\r\n    if (output[\"Initiated\"] !== undefined) {\r\n        contents.Initiated = new Date(output[\"Initiated\"]);\r\n    }\r\n    if (output[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(output[\"Owner\"], context);\r\n    }\r\n    if (output[\"Initiator\"] !== undefined) {\r\n        contents.Initiator = deserializeAws_restXmlInitiator(output[\"Initiator\"], context);\r\n    }\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlMultipartUploadList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlMultipartUpload(entry, context));\r\n};\r\nconst deserializeAws_restXmlNoncurrentVersionExpiration = (output, context) => {\r\n    let contents = {\r\n        __type: \"NoncurrentVersionExpiration\",\r\n        NoncurrentDays: undefined,\r\n    };\r\n    if (output[\"NoncurrentDays\"] !== undefined) {\r\n        contents.NoncurrentDays = parseInt(output[\"NoncurrentDays\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlNoncurrentVersionTransition = (output, context) => {\r\n    let contents = {\r\n        __type: \"NoncurrentVersionTransition\",\r\n        NoncurrentDays: undefined,\r\n        StorageClass: undefined,\r\n    };\r\n    if (output[\"NoncurrentDays\"] !== undefined) {\r\n        contents.NoncurrentDays = parseInt(output[\"NoncurrentDays\"]);\r\n    }\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlNoncurrentVersionTransitionList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlNoncurrentVersionTransition(entry, context));\r\n};\r\nconst deserializeAws_restXmlNotificationConfigurationFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"NotificationConfigurationFilter\",\r\n        Key: undefined,\r\n    };\r\n    if (output[\"S3Key\"] !== undefined) {\r\n        contents.Key = deserializeAws_restXmlS3KeyFilter(output[\"S3Key\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXml_Object = (output, context) => {\r\n    let contents = {\r\n        __type: \"Object\",\r\n        Owner: undefined,\r\n        StorageClass: undefined,\r\n        LastModified: undefined,\r\n        ETag: undefined,\r\n        Size: undefined,\r\n        Key: undefined,\r\n    };\r\n    if (output[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(output[\"Owner\"], context);\r\n    }\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    if (output[\"ETag\"] !== undefined) {\r\n        contents.ETag = output[\"ETag\"];\r\n    }\r\n    if (output[\"Size\"] !== undefined) {\r\n        contents.Size = parseInt(output[\"Size\"]);\r\n    }\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXml_Object(entry, context));\r\n};\r\nconst deserializeAws_restXmlObjectLockConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"ObjectLockConfiguration\",\r\n        ObjectLockEnabled: undefined,\r\n        Rule: undefined,\r\n    };\r\n    if (output[\"ObjectLockEnabled\"] !== undefined) {\r\n        contents.ObjectLockEnabled = output[\"ObjectLockEnabled\"];\r\n    }\r\n    if (output[\"Rule\"] !== undefined) {\r\n        contents.Rule = deserializeAws_restXmlObjectLockRule(output[\"Rule\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectLockLegalHold = (output, context) => {\r\n    let contents = {\r\n        __type: \"ObjectLockLegalHold\",\r\n        Status: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectLockRetention = (output, context) => {\r\n    let contents = {\r\n        __type: \"ObjectLockRetention\",\r\n        Mode: undefined,\r\n        RetainUntilDate: undefined,\r\n    };\r\n    if (output[\"Mode\"] !== undefined) {\r\n        contents.Mode = output[\"Mode\"];\r\n    }\r\n    if (output[\"RetainUntilDate\"] !== undefined) {\r\n        contents.RetainUntilDate = new Date(output[\"RetainUntilDate\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectLockRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"ObjectLockRule\",\r\n        DefaultRetention: undefined,\r\n    };\r\n    if (output[\"DefaultRetention\"] !== undefined) {\r\n        contents.DefaultRetention = deserializeAws_restXmlDefaultRetention(output[\"DefaultRetention\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectVersion = (output, context) => {\r\n    let contents = {\r\n        __type: \"ObjectVersion\",\r\n        StorageClass: undefined,\r\n        IsLatest: undefined,\r\n        Owner: undefined,\r\n        ETag: undefined,\r\n        VersionId: undefined,\r\n        Size: undefined,\r\n        Key: undefined,\r\n        LastModified: undefined,\r\n    };\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    if (output[\"IsLatest\"] !== undefined) {\r\n        contents.IsLatest = output[\"IsLatest\"] == \"true\";\r\n    }\r\n    if (output[\"Owner\"] !== undefined) {\r\n        contents.Owner = deserializeAws_restXmlOwner(output[\"Owner\"], context);\r\n    }\r\n    if (output[\"ETag\"] !== undefined) {\r\n        contents.ETag = output[\"ETag\"];\r\n    }\r\n    if (output[\"VersionId\"] !== undefined) {\r\n        contents.VersionId = output[\"VersionId\"];\r\n    }\r\n    if (output[\"Size\"] !== undefined) {\r\n        contents.Size = parseInt(output[\"Size\"]);\r\n    }\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlObjectVersionList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlObjectVersion(entry, context));\r\n};\r\nconst deserializeAws_restXmlOwner = (output, context) => {\r\n    let contents = {\r\n        __type: \"Owner\",\r\n        DisplayName: undefined,\r\n        ID: undefined,\r\n    };\r\n    if (output[\"DisplayName\"] !== undefined) {\r\n        contents.DisplayName = output[\"DisplayName\"];\r\n    }\r\n    if (output[\"ID\"] !== undefined) {\r\n        contents.ID = output[\"ID\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlPart = (output, context) => {\r\n    let contents = {\r\n        __type: \"Part\",\r\n        ETag: undefined,\r\n        PartNumber: undefined,\r\n        LastModified: undefined,\r\n        Size: undefined,\r\n    };\r\n    if (output[\"ETag\"] !== undefined) {\r\n        contents.ETag = output[\"ETag\"];\r\n    }\r\n    if (output[\"PartNumber\"] !== undefined) {\r\n        contents.PartNumber = parseInt(output[\"PartNumber\"]);\r\n    }\r\n    if (output[\"LastModified\"] !== undefined) {\r\n        contents.LastModified = new Date(output[\"LastModified\"]);\r\n    }\r\n    if (output[\"Size\"] !== undefined) {\r\n        contents.Size = parseInt(output[\"Size\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlParts = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlPart(entry, context));\r\n};\r\nconst deserializeAws_restXmlPolicyStatus = (output, context) => {\r\n    let contents = {\r\n        __type: \"PolicyStatus\",\r\n        IsPublic: undefined,\r\n    };\r\n    if (output[\"IsPublic\"] !== undefined) {\r\n        contents.IsPublic = output[\"IsPublic\"] == \"true\";\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlPublicAccessBlockConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"PublicAccessBlockConfiguration\",\r\n        RestrictPublicBuckets: undefined,\r\n        BlockPublicAcls: undefined,\r\n        IgnorePublicAcls: undefined,\r\n        BlockPublicPolicy: undefined,\r\n    };\r\n    if (output[\"RestrictPublicBuckets\"] !== undefined) {\r\n        contents.RestrictPublicBuckets = output[\"RestrictPublicBuckets\"] == \"true\";\r\n    }\r\n    if (output[\"BlockPublicAcls\"] !== undefined) {\r\n        contents.BlockPublicAcls = output[\"BlockPublicAcls\"] == \"true\";\r\n    }\r\n    if (output[\"IgnorePublicAcls\"] !== undefined) {\r\n        contents.IgnorePublicAcls = output[\"IgnorePublicAcls\"] == \"true\";\r\n    }\r\n    if (output[\"BlockPublicPolicy\"] !== undefined) {\r\n        contents.BlockPublicPolicy = output[\"BlockPublicPolicy\"] == \"true\";\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlQueueConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"QueueConfiguration\",\r\n        Id: undefined,\r\n        Events: undefined,\r\n        QueueArn: undefined,\r\n        Filter: undefined,\r\n    };\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    if (output.Event === \"\") {\r\n        contents.Events = [];\r\n    }\r\n    if (output[\"Event\"] !== undefined) {\r\n        contents.Events = deserializeAws_restXmlEventList(__getArrayIfSingleItem(output[\"Event\"]), context);\r\n    }\r\n    if (output[\"Queue\"] !== undefined) {\r\n        contents.QueueArn = output[\"Queue\"];\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(output[\"Filter\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlQueueConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlQueueConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlRedirect = (output, context) => {\r\n    let contents = {\r\n        __type: \"Redirect\",\r\n        Protocol: undefined,\r\n        ReplaceKeyWith: undefined,\r\n        ReplaceKeyPrefixWith: undefined,\r\n        HostName: undefined,\r\n        HttpRedirectCode: undefined,\r\n    };\r\n    if (output[\"Protocol\"] !== undefined) {\r\n        contents.Protocol = output[\"Protocol\"];\r\n    }\r\n    if (output[\"ReplaceKeyWith\"] !== undefined) {\r\n        contents.ReplaceKeyWith = output[\"ReplaceKeyWith\"];\r\n    }\r\n    if (output[\"ReplaceKeyPrefixWith\"] !== undefined) {\r\n        contents.ReplaceKeyPrefixWith = output[\"ReplaceKeyPrefixWith\"];\r\n    }\r\n    if (output[\"HostName\"] !== undefined) {\r\n        contents.HostName = output[\"HostName\"];\r\n    }\r\n    if (output[\"HttpRedirectCode\"] !== undefined) {\r\n        contents.HttpRedirectCode = output[\"HttpRedirectCode\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlRedirectAllRequestsTo = (output, context) => {\r\n    let contents = {\r\n        __type: \"RedirectAllRequestsTo\",\r\n        Protocol: undefined,\r\n        HostName: undefined,\r\n    };\r\n    if (output[\"Protocol\"] !== undefined) {\r\n        contents.Protocol = output[\"Protocol\"];\r\n    }\r\n    if (output[\"HostName\"] !== undefined) {\r\n        contents.HostName = output[\"HostName\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationConfiguration\",\r\n        Role: undefined,\r\n        Rules: undefined,\r\n    };\r\n    if (output[\"Role\"] !== undefined) {\r\n        contents.Role = output[\"Role\"];\r\n    }\r\n    if (output.Rule === \"\") {\r\n        contents.Rules = [];\r\n    }\r\n    if (output[\"Rule\"] !== undefined) {\r\n        contents.Rules = deserializeAws_restXmlReplicationRules(__getArrayIfSingleItem(output[\"Rule\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationRule\",\r\n        Status: undefined,\r\n        Priority: undefined,\r\n        Destination: undefined,\r\n        ID: undefined,\r\n        SourceSelectionCriteria: undefined,\r\n        Prefix: undefined,\r\n        Filter: undefined,\r\n        ExistingObjectReplication: undefined,\r\n        DeleteMarkerReplication: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    if (output[\"Priority\"] !== undefined) {\r\n        contents.Priority = parseInt(output[\"Priority\"]);\r\n    }\r\n    if (output[\"Destination\"] !== undefined) {\r\n        contents.Destination = deserializeAws_restXmlDestination(output[\"Destination\"], context);\r\n    }\r\n    if (output[\"ID\"] !== undefined) {\r\n        contents.ID = output[\"ID\"];\r\n    }\r\n    if (output[\"SourceSelectionCriteria\"] !== undefined) {\r\n        contents.SourceSelectionCriteria = deserializeAws_restXmlSourceSelectionCriteria(output[\"SourceSelectionCriteria\"], context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlReplicationRuleFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output[\"ExistingObjectReplication\"] !== undefined) {\r\n        contents.ExistingObjectReplication = deserializeAws_restXmlExistingObjectReplication(output[\"ExistingObjectReplication\"], context);\r\n    }\r\n    if (output[\"DeleteMarkerReplication\"] !== undefined) {\r\n        contents.DeleteMarkerReplication = deserializeAws_restXmlDeleteMarkerReplication(output[\"DeleteMarkerReplication\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationRuleAndOperator = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationRuleAndOperator\",\r\n        Tags: undefined,\r\n        Prefix: undefined,\r\n    };\r\n    if (output.Tag === \"\") {\r\n        contents.Tags = [];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tags = deserializeAws_restXmlTagSet(__getArrayIfSingleItem(output[\"Tag\"]), context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationRuleFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationRuleFilter\",\r\n        And: undefined,\r\n        Prefix: undefined,\r\n        Tag: undefined,\r\n    };\r\n    if (output[\"And\"] !== undefined) {\r\n        contents.And = deserializeAws_restXmlReplicationRuleAndOperator(output[\"And\"], context);\r\n    }\r\n    if (output[\"Prefix\"] !== undefined) {\r\n        contents.Prefix = output[\"Prefix\"];\r\n    }\r\n    if (output[\"Tag\"] !== undefined) {\r\n        contents.Tag = deserializeAws_restXmlTag(output[\"Tag\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationRules = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlReplicationRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlReplicationTime = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationTime\",\r\n        Status: undefined,\r\n        Time: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    if (output[\"Time\"] !== undefined) {\r\n        contents.Time = deserializeAws_restXmlReplicationTimeValue(output[\"Time\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlReplicationTimeValue = (output, context) => {\r\n    let contents = {\r\n        __type: \"ReplicationTimeValue\",\r\n        Minutes: undefined,\r\n    };\r\n    if (output[\"Minutes\"] !== undefined) {\r\n        contents.Minutes = parseInt(output[\"Minutes\"]);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlRoutingRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"RoutingRule\",\r\n        Condition: undefined,\r\n        Redirect: undefined,\r\n    };\r\n    if (output[\"Condition\"] !== undefined) {\r\n        contents.Condition = deserializeAws_restXmlCondition(output[\"Condition\"], context);\r\n    }\r\n    if (output[\"Redirect\"] !== undefined) {\r\n        contents.Redirect = deserializeAws_restXmlRedirect(output[\"Redirect\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlRoutingRules = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlRoutingRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlS3KeyFilter = (output, context) => {\r\n    let contents = {\r\n        __type: \"S3KeyFilter\",\r\n        FilterRules: undefined,\r\n    };\r\n    if (output.FilterRule === \"\") {\r\n        contents.FilterRules = [];\r\n    }\r\n    if (output[\"FilterRule\"] !== undefined) {\r\n        contents.FilterRules = deserializeAws_restXmlFilterRuleList(__getArrayIfSingleItem(output[\"FilterRule\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlServerSideEncryptionByDefault = (output, context) => {\r\n    let contents = {\r\n        __type: \"ServerSideEncryptionByDefault\",\r\n        KMSMasterKeyID: undefined,\r\n        SSEAlgorithm: undefined,\r\n    };\r\n    if (output[\"KMSMasterKeyID\"] !== undefined) {\r\n        contents.KMSMasterKeyID = output[\"KMSMasterKeyID\"];\r\n    }\r\n    if (output[\"SSEAlgorithm\"] !== undefined) {\r\n        contents.SSEAlgorithm = output[\"SSEAlgorithm\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlServerSideEncryptionConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"ServerSideEncryptionConfiguration\",\r\n        Rules: undefined,\r\n    };\r\n    if (output.Rule === \"\") {\r\n        contents.Rules = [];\r\n    }\r\n    if (output[\"Rule\"] !== undefined) {\r\n        contents.Rules = deserializeAws_restXmlServerSideEncryptionRules(__getArrayIfSingleItem(output[\"Rule\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlServerSideEncryptionRule = (output, context) => {\r\n    let contents = {\r\n        __type: \"ServerSideEncryptionRule\",\r\n        ApplyServerSideEncryptionByDefault: undefined,\r\n    };\r\n    if (output[\"ApplyServerSideEncryptionByDefault\"] !== undefined) {\r\n        contents.ApplyServerSideEncryptionByDefault = deserializeAws_restXmlServerSideEncryptionByDefault(output[\"ApplyServerSideEncryptionByDefault\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlServerSideEncryptionRules = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlServerSideEncryptionRule(entry, context));\r\n};\r\nconst deserializeAws_restXmlSourceSelectionCriteria = (output, context) => {\r\n    let contents = {\r\n        __type: \"SourceSelectionCriteria\",\r\n        SseKmsEncryptedObjects: undefined,\r\n    };\r\n    if (output[\"SseKmsEncryptedObjects\"] !== undefined) {\r\n        contents.SseKmsEncryptedObjects = deserializeAws_restXmlSseKmsEncryptedObjects(output[\"SseKmsEncryptedObjects\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlSSEKMS = (output, context) => {\r\n    let contents = {\r\n        __type: \"SSEKMS\",\r\n        KeyId: undefined,\r\n    };\r\n    if (output[\"KeyId\"] !== undefined) {\r\n        contents.KeyId = output[\"KeyId\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlSseKmsEncryptedObjects = (output, context) => {\r\n    let contents = {\r\n        __type: \"SseKmsEncryptedObjects\",\r\n        Status: undefined,\r\n    };\r\n    if (output[\"Status\"] !== undefined) {\r\n        contents.Status = output[\"Status\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlSSES3 = (output, context) => {\r\n    let contents = {\r\n        __type: \"SSES3\",\r\n    };\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlStorageClassAnalysis = (output, context) => {\r\n    let contents = {\r\n        __type: \"StorageClassAnalysis\",\r\n        DataExport: undefined,\r\n    };\r\n    if (output[\"DataExport\"] !== undefined) {\r\n        contents.DataExport = deserializeAws_restXmlStorageClassAnalysisDataExport(output[\"DataExport\"], context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlStorageClassAnalysisDataExport = (output, context) => {\r\n    let contents = {\r\n        __type: \"StorageClassAnalysisDataExport\",\r\n        Destination: undefined,\r\n        OutputSchemaVersion: undefined,\r\n    };\r\n    if (output[\"Destination\"] !== undefined) {\r\n        contents.Destination = deserializeAws_restXmlAnalyticsExportDestination(output[\"Destination\"], context);\r\n    }\r\n    if (output[\"OutputSchemaVersion\"] !== undefined) {\r\n        contents.OutputSchemaVersion = output[\"OutputSchemaVersion\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlTag = (output, context) => {\r\n    let contents = {\r\n        __type: \"Tag\",\r\n        Key: undefined,\r\n        Value: undefined,\r\n    };\r\n    if (output[\"Key\"] !== undefined) {\r\n        contents.Key = output[\"Key\"];\r\n    }\r\n    if (output[\"Value\"] !== undefined) {\r\n        contents.Value = output[\"Value\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlTagSet = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlTag(entry, context));\r\n};\r\nconst deserializeAws_restXmlTargetGrant = (output, context) => {\r\n    let contents = {\r\n        __type: \"TargetGrant\",\r\n        Grantee: undefined,\r\n        Permission: undefined,\r\n    };\r\n    if (output[\"Grantee\"] !== undefined) {\r\n        contents.Grantee = deserializeAws_restXmlGrantee(output[\"Grantee\"], context);\r\n    }\r\n    if (output[\"Permission\"] !== undefined) {\r\n        contents.Permission = output[\"Permission\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlTargetGrants = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlTargetGrant(entry, context));\r\n};\r\nconst deserializeAws_restXmlTopicConfiguration = (output, context) => {\r\n    let contents = {\r\n        __type: \"TopicConfiguration\",\r\n        TopicArn: undefined,\r\n        Id: undefined,\r\n        Filter: undefined,\r\n        Events: undefined,\r\n    };\r\n    if (output[\"Topic\"] !== undefined) {\r\n        contents.TopicArn = output[\"Topic\"];\r\n    }\r\n    if (output[\"Id\"] !== undefined) {\r\n        contents.Id = output[\"Id\"];\r\n    }\r\n    if (output[\"Filter\"] !== undefined) {\r\n        contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(output[\"Filter\"], context);\r\n    }\r\n    if (output.Event === \"\") {\r\n        contents.Events = [];\r\n    }\r\n    if (output[\"Event\"] !== undefined) {\r\n        contents.Events = deserializeAws_restXmlEventList(__getArrayIfSingleItem(output[\"Event\"]), context);\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlTopicConfigurationList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlTopicConfiguration(entry, context));\r\n};\r\nconst deserializeAws_restXmlTransition = (output, context) => {\r\n    let contents = {\r\n        __type: \"Transition\",\r\n        Date: undefined,\r\n        Days: undefined,\r\n        StorageClass: undefined,\r\n    };\r\n    if (output[\"Date\"] !== undefined) {\r\n        contents.Date = new Date(output[\"Date\"]);\r\n    }\r\n    if (output[\"Days\"] !== undefined) {\r\n        contents.Days = parseInt(output[\"Days\"]);\r\n    }\r\n    if (output[\"StorageClass\"] !== undefined) {\r\n        contents.StorageClass = output[\"StorageClass\"];\r\n    }\r\n    return contents;\r\n};\r\nconst deserializeAws_restXmlTransitionList = (output, context) => {\r\n    return (output || []).map((entry) => deserializeAws_restXmlTransition(entry, context));\r\n};\r\nconst deserializeMetadata = (output) => ({\r\n    httpStatusCode: output.statusCode,\r\n    httpHeaders: output.headers,\r\n    requestId: output.headers[\"x-amzn-requestid\"],\r\n});\r\n// Collect low-level response body stream to Uint8Array.\r\nconst collectBody = (streamBody = new Uint8Array(), context) => {\r\n    if (streamBody instanceof Uint8Array) {\r\n        return Promise.resolve(streamBody);\r\n    }\r\n    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());\r\n};\r\n// Encode Uint8Array data into string with utf-8.\r\nconst collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));\r\nconst isSerializableHeaderValue = (value) => value !== undefined &&\r\n    value !== \"\" &&\r\n    (!Object.getOwnPropertyNames(value).includes(\"length\") || value.length != 0) &&\r\n    (!Object.getOwnPropertyNames(value).includes(\"size\") || value.size != 0);\r\nconst decodeEscapedXML = (str) => str\r\n    .replace(/&amp;/g, \"&\")\r\n    .replace(/&apos;/g, \"'\")\r\n    .replace(/&quot;/g, '\"')\r\n    .replace(/&gt;/g, \">\")\r\n    .replace(/&lt;/g, \"<\");\r\nconst parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {\r\n    if (encoded.length) {\r\n        const parsedObj = xmlParse(encoded, {\r\n            attributeNamePrefix: \"\",\r\n            ignoreAttributes: false,\r\n            parseNodeValue: false,\r\n            tagValueProcessor: (val, tagName) => decodeEscapedXML(val),\r\n        });\r\n        const textNodeName = \"#text\";\r\n        const key = Object.keys(parsedObj)[0];\r\n        const parsedObjToReturn = parsedObj[key];\r\n        if (parsedObjToReturn[textNodeName]) {\r\n            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\r\n            delete parsedObjToReturn[textNodeName];\r\n        }\r\n        return __getValueFromTextNode(parsedObjToReturn);\r\n    }\r\n    return {};\r\n});\r\nconst loadRestXmlErrorCode = (output, data) => {\r\n    if (data.Code !== undefined) {\r\n        return data.Code;\r\n    }\r\n    if (output.statusCode == 404) {\r\n        return \"NotFound\";\r\n    }\r\n    return \"\";\r\n};\r\n","references":["/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/AbortMultipartUploadCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/CompleteMultipartUploadCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/CopyObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/CreateBucketCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/CreateMultipartUploadCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketAnalyticsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketCorsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketEncryptionCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketInventoryConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketLifecycleCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketMetricsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketPolicyCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketReplicationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteBucketWebsiteCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteObjectTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeleteObjectsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/DeletePublicAccessBlockCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketAccelerateConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketAclCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketAnalyticsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketCorsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketEncryptionCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketInventoryConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketLifecycleConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketLocationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketLoggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketMetricsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketNotificationConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketPolicyCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketPolicyStatusCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketReplicationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketRequestPaymentCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketVersioningCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetBucketWebsiteCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectAclCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectLegalHoldCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectLockConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectRetentionCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetObjectTorrentCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/GetPublicAccessBlockCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/HeadBucketCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/HeadObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListBucketAnalyticsConfigurationsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListBucketInventoryConfigurationsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListBucketMetricsConfigurationsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListBucketsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListMultipartUploadsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListObjectVersionsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListObjectsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListObjectsV2Command.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/ListPartsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketAccelerateConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketAclCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketAnalyticsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketCorsCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketEncryptionCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketInventoryConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketLifecycleConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketLoggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketMetricsConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketNotificationConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketPolicyCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketReplicationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketRequestPaymentCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketVersioningCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutBucketWebsiteCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectAclCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectLegalHoldCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectLockConfigurationCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectRetentionCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectTaggingCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutPublicAccessBlockCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/RestoreObjectCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/SelectObjectContentCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/UploadPartCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/UploadPartCopyCommand.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/models/index.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/protocol-http/dist/cjs/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/smithy-client/dist/cjs/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/types/dist/cjs/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/xml-builder/dist/cjs/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/fast-xml-parser/src/parser.d.ts"]}
