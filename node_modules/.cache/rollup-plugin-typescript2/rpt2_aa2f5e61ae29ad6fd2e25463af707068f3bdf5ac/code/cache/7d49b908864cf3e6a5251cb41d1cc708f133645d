{"code":"// @ts-ignore\r\nimport PrerenderManifest from \"./prerender-manifest.json\";\r\n// @ts-ignore\r\nimport Manifest from \"./manifest.json\";\r\n// @ts-ignore\r\nimport { basePath } from \"./routes-manifest.json\";\r\nimport lambdaAtEdgeCompat from \"@sls-next/next-aws-cloudfront\";\r\nimport cookie from \"cookie\";\r\nimport { performance } from \"perf_hooks\";\r\nimport jsonwebtoken from \"jsonwebtoken\";\r\nconst NEXT_PREVIEW_DATA_COOKIE = \"__next_preview_data\";\r\nconst NEXT_PRERENDER_BYPASS_COOKIE = \"__prerender_bypass\";\r\nconst defaultPreviewCookies = {\r\n    [NEXT_PRERENDER_BYPASS_COOKIE]: \"\",\r\n    [NEXT_PREVIEW_DATA_COOKIE]: \"\"\r\n};\r\nconst getPreviewCookies = (request) => {\r\n    const targetCookie = request.headers.cookie || [];\r\n    return targetCookie.reduce((previewCookies, cookieObj) => {\r\n        const cookieValue = cookie.parse(cookieObj.value);\r\n        if (cookieValue[NEXT_PREVIEW_DATA_COOKIE] &&\r\n            cookieValue[NEXT_PRERENDER_BYPASS_COOKIE]) {\r\n            return cookieValue;\r\n        }\r\n        else {\r\n            return previewCookies;\r\n        }\r\n    }, defaultPreviewCookies);\r\n};\r\nconst perfLogger = (logLambdaExecutionTimes) => {\r\n    if (logLambdaExecutionTimes) {\r\n        return {\r\n            now: () => performance.now(),\r\n            log: (metricDescription, t1, t2) => {\r\n                if (!t1 || !t2)\r\n                    return;\r\n                console.log(`${metricDescription}: ${t2 - t1} (ms)`);\r\n            }\r\n        };\r\n    }\r\n    return {\r\n        now: () => 0,\r\n        log: () => { }\r\n    };\r\n};\r\nconst addS3HostHeader = (req, s3DomainName) => {\r\n    req.headers[\"host\"] = [{ key: \"host\", value: s3DomainName }];\r\n};\r\nconst isDataRequest = (uri) => uri.startsWith(\"/_next/data\");\r\nconst normaliseUri = (uri) => {\r\n    if (basePath) {\r\n        if (uri.startsWith(basePath)) {\r\n            uri = uri.slice(basePath.length);\r\n        }\r\n        else {\r\n            // basePath set but URI does not start with basePath, return 404\r\n            return \"/404\";\r\n        }\r\n    }\r\n    // Remove trailing slash for all paths\r\n    if (uri.endsWith(\"/\")) {\r\n        uri = uri.slice(0, -1);\r\n    }\r\n    // Empty path should be normalised to \"/\" as there is no Next.js route for \"\"\r\n    return uri === \"\" ? \"/\" : uri;\r\n};\r\nconst normaliseS3OriginDomain = (s3Origin) => {\r\n    if (s3Origin.region === \"us-east-1\") {\r\n        return s3Origin.domainName;\r\n    }\r\n    if (!s3Origin.domainName.includes(s3Origin.region)) {\r\n        const regionalEndpoint = s3Origin.domainName.replace(\"s3.amazonaws.com\", `s3.${s3Origin.region}.amazonaws.com`);\r\n        return regionalEndpoint;\r\n    }\r\n    return s3Origin.domainName;\r\n};\r\nconst router = (manifest) => {\r\n    const { pages: { ssr, html } } = manifest;\r\n    const allDynamicRoutes = { ...ssr.dynamic, ...html.dynamic };\r\n    return (uri) => {\r\n        let normalisedUri = uri;\r\n        if (isDataRequest(uri)) {\r\n            normalisedUri = uri\r\n                .replace(`/_next/data/${manifest.buildId}`, \"\")\r\n                .replace(\".json\", \"\");\r\n            // Normalise to \"/\" for index data request\r\n            normalisedUri = [\"/index\", \"\"].includes(normalisedUri)\r\n                ? \"/\"\r\n                : normalisedUri;\r\n        }\r\n        if (ssr.nonDynamic[normalisedUri]) {\r\n            return ssr.nonDynamic[normalisedUri];\r\n        }\r\n        for (const route in allDynamicRoutes) {\r\n            const { file, regex } = allDynamicRoutes[route];\r\n            const re = new RegExp(regex, \"i\");\r\n            const pathMatchesRoute = re.test(normalisedUri);\r\n            if (pathMatchesRoute) {\r\n                return file;\r\n            }\r\n        }\r\n        // only use the 404 page if the project exports it\r\n        if (html.nonDynamic[\"/404\"] !== undefined) {\r\n            return \"pages/404.html\";\r\n        }\r\n        return \"pages/_error.js\";\r\n    };\r\n};\r\nexport const handler = async (event) => {\r\n    const manifest = Manifest;\r\n    let response;\r\n    const prerenderManifest = PrerenderManifest;\r\n    const { now, log } = perfLogger(manifest.logLambdaExecutionTimes);\r\n    const tHandlerBegin = now();\r\n    if (isOriginResponse(event)) {\r\n        response = await handleOriginResponse({\r\n            event,\r\n            manifest,\r\n            prerenderManifest\r\n        });\r\n    }\r\n    else {\r\n        response = await handleOriginRequest({\r\n            event,\r\n            manifest,\r\n            prerenderManifest\r\n        });\r\n    }\r\n    const tHandlerEnd = now();\r\n    log(\"handler execution time\", tHandlerBegin, tHandlerEnd);\r\n    return response;\r\n};\r\nconst handleOriginRequest = async ({ event, manifest, prerenderManifest }) => {\r\n    const request = event.Records[0].cf.request;\r\n    const uri = normaliseUri(request.uri);\r\n    const { pages, publicFiles } = manifest;\r\n    const isPublicFile = publicFiles[uri];\r\n    const isDataReq = isDataRequest(uri);\r\n    // Handle any redirects\r\n    let newUri = request.uri;\r\n    if (isDataReq || isPublicFile) {\r\n        // Data requests and public files with trailing slash URL always get redirected to non-trailing slash URL\r\n        if (newUri.endsWith(\"/\")) {\r\n            newUri = newUri.slice(0, -1);\r\n        }\r\n    }\r\n    else if (request.uri !== \"/\" && request.uri !== \"\" && uri !== \"/404\") {\r\n        // HTML/SSR pages get redirected based on trailingSlash in next.config.js\r\n        // We do not redirect:\r\n        // 1. Unnormalised URI is\"/\" or \"\" as this could cause a redirect loop due to browsers appending trailing slash\r\n        // 2. \"/404\" pages due to basePath normalisation\r\n        const trailingSlash = manifest.trailingSlash;\r\n        if (!trailingSlash && newUri.endsWith(\"/\")) {\r\n            newUri = newUri.slice(0, -1);\r\n        }\r\n        if (trailingSlash && !newUri.endsWith(\"/\")) {\r\n            newUri += \"/\";\r\n        }\r\n    }\r\n    if (newUri !== request.uri) {\r\n        return createRedirectResponse(newUri, request.querystring);\r\n    }\r\n    const isStaticPage = pages.html.nonDynamic[uri];\r\n    const isPrerenderedPage = prerenderManifest.routes[uri]; // prerendered pages are also static pages like \"pages.html\" above, but are defined in the prerender-manifest\r\n    const origin = request.origin;\r\n    const s3Origin = origin.s3;\r\n    const isHTMLPage = isStaticPage || isPrerenderedPage;\r\n    const normalisedS3DomainName = normaliseS3OriginDomain(s3Origin);\r\n    const hasFallback = hasFallbackForUri(uri, prerenderManifest);\r\n    const { now, log } = perfLogger(manifest.logLambdaExecutionTimes);\r\n    const previewCookies = getPreviewCookies(request);\r\n    const isPreviewRequest = previewCookies[NEXT_PREVIEW_DATA_COOKIE] &&\r\n        previewCookies[NEXT_PRERENDER_BYPASS_COOKIE];\r\n    if (isPreviewRequest) {\r\n        try {\r\n            jsonwebtoken.verify(previewCookies[NEXT_PREVIEW_DATA_COOKIE], prerenderManifest.preview.previewModeSigningKey);\r\n        }\r\n        catch (e) {\r\n            console.error(\"Failed preview mode verification for URI:\", request.uri);\r\n            return {\r\n                status: \"403\",\r\n                statusDescription: \"Forbidden\"\r\n            };\r\n        }\r\n    }\r\n    s3Origin.domainName = normalisedS3DomainName;\r\n    S3Check: if (isPublicFile ||\r\n        (isHTMLPage && !isPreviewRequest) ||\r\n        (hasFallback && !isPreviewRequest) ||\r\n        (isDataReq && !isPreviewRequest)) {\r\n        if (isHTMLPage || hasFallback) {\r\n            s3Origin.path = `${basePath}/static-pages`;\r\n            const pageName = uri === \"/\" ? \"/index\" : uri;\r\n            request.uri = `${pageName}.html`;\r\n        }\r\n        if (isPublicFile) {\r\n            s3Origin.path = `${basePath}/public`;\r\n            if (basePath) {\r\n                request.uri = request.uri.replace(basePath, \"\");\r\n            }\r\n        }\r\n        if (isDataReq) {\r\n            // We need to check whether data request is unmatched i.e routed to 404.html or _error.js\r\n            const pagePath = router(manifest)(uri);\r\n            if (pagePath === \"pages/404.html\") {\r\n                // Request static page from s3\r\n                s3Origin.path = `${basePath}/static-pages`;\r\n                request.uri = pagePath.replace(\"pages\", \"\");\r\n            }\r\n            else if (pagePath === \"pages/_error.js\") {\r\n                // Break to continue to SSR render _error.js\r\n                break S3Check;\r\n            }\r\n        }\r\n        addS3HostHeader(request, normalisedS3DomainName);\r\n        return request;\r\n    }\r\n    const pagePath = router(manifest)(uri);\r\n    if (pagePath.endsWith(\".html\") && !isPreviewRequest) {\r\n        s3Origin.path = `${basePath}/static-pages`;\r\n        request.uri = pagePath.replace(\"pages\", \"\");\r\n        addS3HostHeader(request, normalisedS3DomainName);\r\n        return request;\r\n    }\r\n    const tBeforePageRequire = now();\r\n    let page = require(`./${pagePath}`); // eslint-disable-line\r\n    const tAfterPageRequire = now();\r\n    log(\"require JS execution time\", tBeforePageRequire, tAfterPageRequire);\r\n    const tBeforeSSR = now();\r\n    const { req, res, responsePromise } = lambdaAtEdgeCompat(event.Records[0].cf);\r\n    try {\r\n        // If page is _error.js, set status to 404 so _error.js will render a 404 page\r\n        if (pagePath === \"pages/_error.js\") {\r\n            res.statusCode = 404;\r\n        }\r\n        // Render page\r\n        if (isDataReq) {\r\n            const { renderOpts } = await page.renderReqToHTML(req, res, \"passthrough\");\r\n            res.setHeader(\"Content-Type\", \"application/json\");\r\n            res.end(JSON.stringify(renderOpts.pageData));\r\n        }\r\n        else {\r\n            await page.render(req, res);\r\n        }\r\n    }\r\n    catch (error) {\r\n        // Set status to 500 so _error.js will render a 500 page\r\n        console.error(`Error rendering page: ${pagePath}. Error:\\n${error}\\nRendering Next.js error page.`);\r\n        res.statusCode = 500;\r\n        page = require(\"./pages/_error.js\"); // eslint-disable-line\r\n        await page.render(req, res);\r\n    }\r\n    const response = await responsePromise;\r\n    const tAfterSSR = now();\r\n    log(\"SSR execution time\", tBeforeSSR, tAfterSSR);\r\n    setCloudFrontResponseStatus(response, res);\r\n    return response;\r\n};\r\nconst handleOriginResponse = async ({ event, manifest, prerenderManifest }) => {\r\n    var _a, _b;\r\n    const response = event.Records[0].cf.response;\r\n    const request = event.Records[0].cf.request;\r\n    const { status } = response;\r\n    if (status !== \"403\") {\r\n        // Set 404 status code for 404.html page. We do not need normalised URI as it will always be \"/404.html\"\r\n        if (request.uri === \"/404.html\") {\r\n            response.status = \"404\";\r\n            response.statusDescription = \"Not Found\";\r\n        }\r\n        return response;\r\n    }\r\n    const uri = normaliseUri(request.uri);\r\n    const { domainName, region } = request.origin.s3;\r\n    const bucketName = domainName.replace(`.s3.${region}.amazonaws.com`, \"\");\r\n    // Lazily import only S3Client to reduce init times until actually needed\r\n    const { S3Client } = await import(\"@aws-sdk/client-s3/S3Client\");\r\n    const s3 = new S3Client({ region: (_b = (_a = request.origin) === null || _a === void 0 ? void 0 : _a.s3) === null || _b === void 0 ? void 0 : _b.region });\r\n    let pagePath;\r\n    if (isDataRequest(uri) &&\r\n        !(pagePath = router(manifest)(uri)).endsWith(\".html\")) {\r\n        // eslint-disable-next-line\r\n        const page = require(`./${pagePath}`);\r\n        const { req, res, responsePromise } = lambdaAtEdgeCompat(event.Records[0].cf);\r\n        const isSSG = !!page.getStaticProps;\r\n        const { renderOpts, html } = await page.renderReqToHTML(req, res, \"passthrough\");\r\n        if (isSSG) {\r\n            const s3JsonParams = {\r\n                Bucket: bucketName,\r\n                Key: uri.replace(/^\\//, \"\"),\r\n                Body: JSON.stringify(renderOpts.pageData),\r\n                ContentType: \"application/json\"\r\n            };\r\n            const s3HtmlParams = {\r\n                Bucket: bucketName,\r\n                Key: `static-pages/${request.uri\r\n                    .replace(`/_next/data/${manifest.buildId}/`, \"\")\r\n                    .replace(\".json\", \".html\")}`,\r\n                Body: html,\r\n                ContentType: \"text/html\",\r\n                CacheControl: \"public, max-age=0, s-maxage=2678400, must-revalidate\"\r\n            };\r\n            const { PutObjectCommand } = await import(\"@aws-sdk/client-s3/commands/PutObjectCommand\");\r\n            await Promise.all([\r\n                s3.send(new PutObjectCommand(s3JsonParams)),\r\n                s3.send(new PutObjectCommand(s3HtmlParams))\r\n            ]);\r\n        }\r\n        res.writeHead(200, response.headers);\r\n        res.setHeader(\"Content-Type\", \"application/json\");\r\n        res.end(JSON.stringify(renderOpts.pageData));\r\n        return await responsePromise;\r\n    }\r\n    else {\r\n        const hasFallback = hasFallbackForUri(uri, prerenderManifest);\r\n        if (!hasFallback)\r\n            return response;\r\n        const s3Params = {\r\n            Bucket: bucketName,\r\n            Key: `static-pages${hasFallback.fallback}`\r\n        };\r\n        const { GetObjectCommand } = await import(\"@aws-sdk/client-s3/commands/GetObjectCommand\");\r\n        const { Body } = await s3.send(new GetObjectCommand(s3Params));\r\n        // Body is stream per: https://github.com/aws/aws-sdk-js-v3/issues/1096\r\n        const getStream = await import(\"get-stream\");\r\n        const bodyString = await getStream.default(Body);\r\n        return {\r\n            status: \"200\",\r\n            statusDescription: \"OK\",\r\n            headers: {\r\n                ...response.headers,\r\n                \"content-type\": [\r\n                    {\r\n                        key: \"Content-Type\",\r\n                        value: \"text/html\"\r\n                    }\r\n                ]\r\n            },\r\n            body: bodyString\r\n        };\r\n    }\r\n};\r\nconst isOriginResponse = (event) => {\r\n    return event.Records[0].cf.config.eventType === \"origin-response\";\r\n};\r\nconst hasFallbackForUri = (uri, prerenderManifest) => {\r\n    return Object.values(prerenderManifest.dynamicRoutes).find((routeConfig) => {\r\n        const re = new RegExp(routeConfig.routeRegex);\r\n        return re.test(uri);\r\n    });\r\n};\r\nconst createRedirectResponse = (uri, querystring) => {\r\n    const location = querystring ? `${uri}?${querystring}` : uri;\r\n    return {\r\n        status: \"308\",\r\n        statusDescription: \"Permanent Redirect\",\r\n        headers: {\r\n            location: [\r\n                {\r\n                    key: \"Location\",\r\n                    value: location\r\n                }\r\n            ],\r\n            refresh: [\r\n                {\r\n                    key: \"Refresh\",\r\n                    value: `0;url=${location}`\r\n                }\r\n            ]\r\n        }\r\n    };\r\n};\r\n// This sets CloudFront response for 404 or 500 statuses\r\nconst setCloudFrontResponseStatus = (response, res) => {\r\n    if (res.statusCode == 404) {\r\n        response.status = \"404\";\r\n        response.statusDescription = \"Not Found\";\r\n    }\r\n    else if (res.statusCode == 500) {\r\n        response.status = \"500\";\r\n        response.statusDescription = \"Internal Server Error\";\r\n    }\r\n};\r\n","references":["/Users/tim/code/lambda-at-edge/node_modules/@sls-next/next-aws-cloudfront/next-aws-cloudfront.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@types/cookie/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@types/aws-lambda/index.d.ts","/Users/tim/code/lambda-at-edge/types.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@types/jsonwebtoken/index.d.ts","/Users/tim/code/lambda-at-edge/node_modules/@aws-sdk/client-s3/commands/PutObjectCommand.ts"]}
